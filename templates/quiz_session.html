{% extends "base.html" %}

{% block title %}Quiz Session{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row justify-content-center">
        <div class="col-12">
            <!-- Enhanced Quiz Progress -->
            <div class="quiz-progress-card card mb-4 border-0 shadow-sm">
                <div class="card-body py-4">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div class="quiz-progress-info">
                            <h4 class="mb-1 text-primary">Question <span id="current-question" class="fw-bold">1</span> of {{ questions|length }}</h4>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-light text-dark px-3 py-2">{{ difficulty|title }} difficulty</span>
                                <span class="text-muted small">Mixed question types</span>
                            </div>
                        </div>
                        <div class="quiz-progress-visual text-end">
                            <div class="progress-percentage text-primary fw-bold mb-1" id="progress-percentage">0%</div>
                            <div class="progress" style="width: 240px; height: 12px; border-radius: 6px;">
                                <div class="progress-bar bg-primary" id="progress-bar" role="progressbar" style="width: 0%; border-radius: 6px; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="quiz-progress-steps d-flex justify-content-between">
                        {% for i in range(1, questions|length + 1) %}
                        <div class="progress-step" data-step="{{ i }}">
                            <div class="step-circle">{{ i }}</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            
            <!-- Quiz Questions -->
            <div id="quiz-container">
                {% for question in questions %}
                <div class="question-card card mb-4 border-0 shadow-sm" data-question="{{ question.id }}" {% if question.id != 1 %}style="display: none;"{% endif %}>
                    <div class="card-body p-5">
                        <!-- Question Header with improved typography -->
                        <div class="question-header mb-4">
                            {% if question.question_type == "true_false" %}
                                {% set question_parts = question.question.split("'") %}
                                {% if question_parts|length >= 3 %}
                                <div class="question-statement">
                                    <h3 class="question-type-label text-primary mb-3">üìù True or False</h3>
                                    <div class="question-word-highlight mb-3">
                                        <span class="question-prefix text-muted">Does the word</span>
                                        <span class="featured-word">"{{ question_parts[1] }}"</span>
                                        <span class="question-suffix text-muted">mean:</span>
                                    </div>
                                    <div class="definition-block">
                                        {% set definition_part = question.question.split("means '")[1].rstrip("' ") if "means '" in question.question else question.question.split("'")[-2] %}
                                        <blockquote class="definition-quote">
                                            <p class="definition-text">{{ definition_part }}</p>
                                        </blockquote>
                                    </div>
                                </div>
                                {% else %}
                                <h3 class="question-title">{{ question.question }}</h3>
                                {% endif %}
                            {% elif question.question_type == "multiple_choice" %}
                                <h3 class="question-type-label text-primary mb-3">üéØ Multiple Choice</h3>
                                <h4 class="question-title">{{ question.question }}</h4>
                            {% else %}
                                <h4 class="question-title">{{ question.question }}</h4>
                            {% endif %}
                        </div>
                        
                        <!-- Question Options -->
                        <div class="options mt-4">
                            {% if question.question_type == "true_false" %}
                            <!-- Enhanced True/False Options -->
                            <div class="true-false-container">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <div class="tf-option-card true-option">
                                            <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                                   id="option_{{ question.id }}_true" value="true"
                                                   data-question="{{ question.id }}">
                                            <label class="tf-option-label" for="option_{{ question.id }}_true">
                                                <div class="tf-option-content">
                                                    <div class="tf-icon">‚úì</div>
                                                    <div class="tf-text">True</div>
                                                    <div class="tf-description">This definition is correct</div>
                                                </div>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="tf-option-card false-option">
                                            <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                                   id="option_{{ question.id }}_false" value="false"
                                                   data-question="{{ question.id }}">
                                            <label class="tf-option-label" for="option_{{ question.id }}_false">
                                                <div class="tf-option-content">
                                                    <div class="tf-icon">‚úó</div>
                                                    <div class="tf-text">False</div>
                                                    <div class="tf-description">This definition is incorrect</div>
                                                </div>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% elif question.question_type == "matching" %}
                            <!-- Matching Options - Drag Definitions onto Terms -->
                            <div class="matching-container">
                                <div class="matching-instructions mb-4 p-3 bg-light border-left border-primary">
                                    <h6 class="text-primary mb-2">üéØ How to Match</h6>
                                    <p class="mb-0 small">Drag definitions from the right onto the matching terms on the left. Click a definition on a term to remove it if you change your mind.</p>
                                </div>
                                
                                <div class="row">
                                    <!-- Drop Zones for Terms -->
                                    <div class="col-lg-7">
                                        <h6 class="text-primary mb-3">üìù Terms (Drop Definitions Here)</h6>
                                        <div class="terms-list" id="terms-list-{{ question.id }}">
                                            {% for term in question.terms %}
                                            <div class="term-slot card mb-2 p-2 border-primary drop-zone position-relative" 
                                                 data-term-index="{{ loop.index0 }}" 
                                                 data-term="{{ term }}"
                                                 data-question="{{ question.id }}">
                                                <div class="d-flex align-items-start mb-1">
                                                    <div class="term-number badge bg-primary me-2 flex-shrink-0">{{ loop.index }}</div>
                                                    <strong class="term-text flex-shrink-0 me-3">{{ term }}</strong>
                                                    <div class="definition-drop-area flex-grow-1" 
                                                         style="min-height: 40px; border: 2px dashed #dee2e6; border-radius: 6px; padding: 8px; background: #f8f9fa; font-size: 0.9em;">
                                                        <span class="drop-placeholder text-muted" style="font-style: italic;">
                                                            Drop definition here...
                                                        </span>
                                                    </div>
                                                </div>
                                                <input type="hidden" name="match_{{ question.id }}_{{ loop.index0 }}" 
                                                       value="" class="term-match-input">
                                            </div>
                                            {% endfor %}
                                        </div>
                                    </div>
                                    
                                    <!-- Draggable Definitions -->
                                    <div class="col-lg-5">
                                        <h6 class="text-success mb-3">üìö Available Definitions</h6>
                                        <div class="definitions-bank" id="definitions-bank-{{ question.id }}">
                                            {% for definition in question.definitions %}
                                            <div class="definition-item card mb-2 p-2 border-success draggable" 
                                                 draggable="true"
                                                 data-def-index="{{ loop.index0 }}" 
                                                 data-question="{{ question.id }}"
                                                 style="cursor: grab; transition: all 0.3s ease; font-size: 0.9em;">
                                                <div class="d-flex align-items-start">
                                                    <div class="drag-handle me-2 text-muted flex-shrink-0" style="font-size: 0.8em; margin-top: 2px;">
                                                        <i class="fas fa-grip-vertical"></i>
                                                    </div>
                                                    <div class="definition-content flex-grow-1">
                                                        <span class="definition-text">{{ definition }}</span>
                                                    </div>
                                                </div>
                                            </div>
                                            {% endfor %}
                                        </div>
                                        <div class="text-muted text-center mt-3">
                                            üí° Drag these definitions onto the terms
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% else %}
                            <!-- Enhanced Multiple Choice Options -->
                            <div class="options-container">
                                {% for option in question.options %}
                                <div class="option-card mb-3">
                                    <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                           id="option_{{ question.id }}_{{ loop.index0 }}" value="{{ loop.index0 }}"
                                           data-question="{{ question.id }}"
                                           data-word-id="{% if question.option_word_ids %}{{ question.option_word_ids[loop.index0] }}{% endif %}">
                                    <label class="option-label" for="option_{{ question.id }}_{{ loop.index0 }}">
                                        <div class="option-content">
                                            <div class="option-letter">{{ ['A', 'B', 'C', 'D'][loop.index0] }}</div>
                                            <div class="option-text">
                                                {% if '; ' in option %}
                                                    {% set option_parts = option.split('; ') %}
                                                    <div class="option-main">{{ option_parts[0] }}</div>
                                                    {% if option_parts|length > 1 %}
                                                    <div class="option-details">
                                                        {% for detail in option_parts[1:] %}
                                                        <span class="detail-item">{{ detail }}</span>{% if not loop.last %}; {% endif %}
                                                        {% endfor %}
                                                    </div>
                                                    {% endif %}
                                                {% else %}
                                                    <div class="option-main">{{ option }}</div>
                                                {% endif %}
                                            </div>
                                            <div class="option-selector">
                                                <div class="radio-circle"></div>
                                            </div>
                                        </div>
                                    </label>
                                </div>
                                {% endfor %}
                            </div>
                            {% endif %}
                        </div>
                        
                        <!-- Enhanced Answer feedback (hidden initially) -->
                        <div class="answer-feedback mt-5" style="display: none;">
                            <div class="alert" role="alert">
                                <div class="feedback-card border-0 shadow-sm">
                                    <div class="feedback-header">
                                        <div class="feedback-icon"></div>
                                        <div class="feedback-content">
                                            <h5 class="feedback-result mb-1"></h5>
                                            <p class="feedback-explanation mb-0">{{ question.explanation }}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Navigation -->
                        <div class="quiz-navigation mt-5">
                            <div class="d-flex justify-content-between align-items-center">
                                <button class="btn btn-outline-secondary btn-lg px-4" id="prev-btn" onclick="previousQuestion()"
                                        {% if question.id == 1 %}style="visibility: hidden;"{% endif %}>
                                    <i class="fas fa-chevron-left me-2"></i> Previous
                                </button>
                                <div class="navigation-help text-center">
                                    <small class="text-muted">Select an answer to continue</small>
                                </div>
                                <button class="btn btn-primary btn-lg px-4" id="next-btn-{{ question.id }}" onclick="nextQuestion()" disabled>
                                    {% if question.id == questions|length %}
                                        <i class="fas fa-flag-checkered me-2"></i> Finish Quiz
                                    {% else %}
                                        Next <i class="fas fa-chevron-right ms-2"></i>
                                    {% endif %}
                                </button>
                            </div>
                        </div>
                        
                        <!-- Hidden data -->
                        <input type="hidden" class="correct-answer" value="{{ question.correct_answer }}">
                        <input type="hidden" class="word-id" value="{{ question.word_id }}">
                    </div>
                </div>
                {% endfor %}
            </div>
            
            <!-- Quiz Results (hidden initially) -->
            <div id="quiz-results" class="card" style="display: none;">
                <div class="card-body text-center">
                    <h3>üéâ Quiz Complete!</h3>
                    <div class="row mt-4">
                        <div class="col-md-4">
                            <div class="card border-success">
                                <div class="card-body">
                                    <h4 class="text-success" id="correct-count">0</h4>
                                    <p class="mb-0">Correct</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card border-danger">
                                <div class="card-body">
                                    <h4 class="text-danger" id="incorrect-count">0</h4>
                                    <p class="mb-0">Incorrect</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card border-info">
                                <div class="card-body">
                                    <h4 class="text-info" id="accuracy">0%</h4>
                                    <p class="mb-0">Accuracy</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Comprehensive Review Section -->
                    <div id="comprehensive-review" class="mt-5">
                        <div class="card border-info">
                            <div class="card-header bg-info text-white text-start">
                                <h5 class="mb-0">üìù Complete Review - All Terms & Definitions</h5>
                                <small>Review all vocabulary from this quiz, including individual terms from matching questions</small>
                            </div>
                            <div class="card-body" id="review-content">
                                <!-- Review content will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <div class="mt-4">
                        <a href="/quiz" class="btn btn-primary me-2">Take Another Quiz</a>
                        <a href="/" class="btn btn-outline-secondary">Back to Home</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let currentQuestion = 1;
let totalQuestions = {{ questions|length }};
let userAnswers = {};
let correctAnswers = 0;

// Quiz data
const quizData = {
    {% for question in questions %}
    {{ question.id }}: {
        correctAnswer: {% if question.correct_answer is sameas true %}true{% elif question.correct_answer is sameas false %}false{% elif question.correct_answer %}{{ question.correct_answer }}{% else %}null{% endif %},
        {% if question.question_type == "matching" %}
        correctMatches: {{ question.correct_matches|tojson }},
        terms: {{ question.terms|tojson }},
        definitions: {{ question.definitions|tojson }},
        {% elif question.question_type == "multiple_choice" %}
        options: {{ question.options|tojson }},
        {% endif %}
        wordId: {{ question.word_id }},
        questionType: "{{ question.question_type }}",
        explanation: "{{ question.explanation|replace('"', '\\"') }}"
    }{% if not loop.last %},{% endif %}
    {% endfor %}
};

const sessionId = "{{ session_id }}";

function updateProgress() {
    const progress = ((currentQuestion - 1) / totalQuestions) * 100;
    document.getElementById('progress-bar').style.width = progress + '%';
    document.getElementById('current-question').textContent = currentQuestion;

    // Update percentage display
    const percentageElement = document.getElementById('progress-percentage');
    if (percentageElement) {
        percentageElement.textContent = Math.round(progress) + '%';
    }

    // Update progress steps
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((step, index) => {
        const stepNumber = index + 1;
        step.classList.remove('completed', 'current');

        if (stepNumber < currentQuestion) {
            step.classList.add('completed');
        } else if (stepNumber === currentQuestion) {
            step.classList.add('current');
        }
    });
}

function showQuestion(questionNum) {
    // Hide all questions
    document.querySelectorAll('.question-card').forEach(card => {
        card.style.display = 'none';
    });
    
    // Show current question
    const currentCard = document.querySelector(`[data-question="${questionNum}"]`);
    if (currentCard) {
        currentCard.style.display = 'block';
    }
    
    // Update navigation buttons
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById(`next-btn-${questionNum}`);
    
    if (questionNum === 1) {
        prevBtn.style.visibility = 'hidden';
    } else {
        prevBtn.style.visibility = 'visible';
    }
    
    if (questionNum === totalQuestions) {
        nextBtn.textContent = 'Finish Quiz';
    } else {
        nextBtn.textContent = 'Next ‚Üí';
    }
    
    // Check if question is already answered
    const selectedOption = document.querySelector(`input[name="answer_${questionNum}"]:checked`);
    nextBtn.disabled = !selectedOption;
    
    // For matching questions, check if they need button state fix
    const currentQuestionData = quizData[questionNum - 1];
    if (currentQuestionData && currentQuestionData.questionType === 'matching') {
        // IMMEDIATE check - no delay
        checkMatchingCompletion(questionNum);
        
        // Multiple checks with increasing delays to ensure reliability
        setTimeout(() => {
            checkMatchingCompletion(questionNum);
        }, 100);
        setTimeout(() => {
            checkMatchingCompletion(questionNum);
        }, 300);
        setTimeout(() => {
            checkMatchingCompletion(questionNum);
        }, 600);
        setTimeout(() => {
            checkMatchingCompletion(questionNum);
        }, 1000);
    }
}

function nextQuestion() {
    const questionType = quizData[currentQuestion].questionType;
    console.log('Next question clicked, current:', currentQuestion, 'type:', questionType);
    
    let userAnswer, correctAnswer, isCorrect;
    
    if (questionType === "matching") {
        // Handle matching questions - collect matches from hidden inputs
        const termSlots = document.querySelectorAll(`.term-slot[data-question="${currentQuestion}"]`);
        const userMatches = {};
        let allMatched = true;
        
        termSlots.forEach(slot => {
            const termIndex = parseInt(slot.dataset.termIndex);
            const hiddenInput = slot.querySelector('.term-match-input');
            const defIndex = hiddenInput ? hiddenInput.value : '';
            
            if (defIndex === '') {
                allMatched = false;
            } else {
                userMatches[termIndex] = parseInt(defIndex);
            }
        });
        
        if (!allMatched) {
            console.error('Not all matches completed for question', currentQuestion);
            return;
        }
        
        // Check correctness per term against quiz data
        const questionData = quizData[currentQuestion];
        const correctMatches = questionData.correctMatches;
        let correctTermCount = 0;
        let totalTermCount = 0;
        const termResults = {};

        for (let termIdx in userMatches) {
            totalTermCount++;
            const isTermCorrect = userMatches[termIdx] === correctMatches[termIdx];
            if (isTermCorrect) {
                correctTermCount++;
            }
            termResults[termIdx] = {
                userAnswer: userMatches[termIdx],
                correctAnswer: correctMatches[termIdx],
                isCorrect: isTermCorrect
            };
        }

        // Add the correct term count to the overall score
        correctAnswers += correctTermCount;
        
        // Store user answer with per-term results
        userAnswers[currentQuestion] = {
            matches: userMatches,
            questionType: 'matching',
            termResults: termResults,
            correctTermCount: correctTermCount,
            totalTermCount: totalTermCount,
            isCorrect: correctTermCount === totalTermCount // All terms correct
        };

        console.log('Stored matching answer:', userMatches, 'Per-term results:', termResults, `${correctTermCount}/${totalTermCount} correct`);
        
        // Show matching feedback with per-term results
        showMatchingFeedback(currentQuestion, userMatches, correctMatches, termResults, correctTermCount, totalTermCount);
        
        // Continue with next question after delay (like other question types)
        setTimeout(() => {
            if (currentQuestion < totalQuestions) {
                currentQuestion++;
                showQuestion(currentQuestion);
                updateProgress();
            } else {
                showResults();
            }
        }, 2000);
        return;
    }
    
    // Handle multiple choice and true/false questions
    const selectedOption = document.querySelector(`input[name="answer_${currentQuestion}"]:checked`);
    if (!selectedOption) return;
    
    if (questionType === "true_false") {
        userAnswer = selectedOption.value === "true";
        correctAnswer = quizData[currentQuestion].correctAnswer;
        isCorrect = userAnswer === correctAnswer;
    } else {
        userAnswer = parseInt(selectedOption.value);
        correctAnswer = quizData[currentQuestion].correctAnswer;
        // Ensure both are same type for comparison - critical bug fix
        isCorrect = userAnswer === parseInt(correctAnswer);
    }
    
    // Get the chosen distractor word ID for mistake tracking
    const chosenDistractorId = selectedOption.getAttribute('data-word-id');
    
    // Store user answer
    userAnswers[currentQuestion] = {
        selected: userAnswer,
        correct: correctAnswer,
        isCorrect: isCorrect,
        chosenDistractorId: chosenDistractorId
    };
    
    if (isCorrect) {
        correctAnswers++;
    }
    
    // Show feedback
    showFeedback(currentQuestion, isCorrect);
    
    // Move to next question after delay
    setTimeout(() => {
        if (currentQuestion < totalQuestions) {
            currentQuestion++;
            showQuestion(currentQuestion);
            updateProgress();
        } else {
            showResults();
        }
    }, 2000);
}

function previousQuestion() {
    if (currentQuestion > 1) {
        currentQuestion--;
        showQuestion(currentQuestion);
        updateProgress();
        
        // Check if this is a matching question and fix button state if needed
        const currentQuestionData = quizData[currentQuestion];
        if (currentQuestionData && currentQuestionData.questionType === 'matching') {
            // IMMEDIATE check - no delay
            checkMatchingCompletion(currentQuestion);
            
            // Multiple checks with increasing delays to ensure reliability
            setTimeout(() => {
                checkMatchingCompletion(currentQuestion);
            }, 50);
            setTimeout(() => {
                checkMatchingCompletion(currentQuestion);
            }, 200);
            setTimeout(() => {
                checkMatchingCompletion(currentQuestion);
            }, 500);
            setTimeout(() => {
                checkMatchingCompletion(currentQuestion);
            }, 1000);
        }
    }
}

function showFeedback(questionNum, isCorrect) {
    const feedbackDiv = document.querySelector(`[data-question="${questionNum}"] .answer-feedback`);
    const resultSpan = feedbackDiv.querySelector('.feedback-result');
    const alertDiv = feedbackDiv.querySelector('.feedback-card');

    if (isCorrect) {
        feedbackDiv.querySelector('.alert').className = 'alert alert-success';
        resultSpan.textContent = 'Correct!';
    } else {
        feedbackDiv.querySelector('.alert').className = 'alert alert-danger';
        resultSpan.textContent = 'Incorrect';
    }

    feedbackDiv.style.display = 'block';

    // Disable all options
    document.querySelectorAll(`input[name="answer_${questionNum}"]`).forEach(input => {
        input.disabled = true;
    });

    // Update navigation help text
    const navHelp = document.querySelector('.navigation-help small');
    if (navHelp) {
        navHelp.textContent = 'Review the feedback and continue';
    }
}

function showResults() {
    // Hide quiz container
    document.getElementById('quiz-container').style.display = 'none';

    // Show results
    const resultsDiv = document.getElementById('quiz-results');
    resultsDiv.style.display = 'block';

    // Calculate actual total questions including individual terms in matching questions
    let actualTotalQuestions = 0;
    for (let i = 1; i <= totalQuestions; i++) {
        if (userAnswers[i] && userAnswers[i].questionType === 'matching') {
            actualTotalQuestions += userAnswers[i].totalTermCount;
        } else {
            actualTotalQuestions += 1; // Regular question counts as 1
        }
    }

    // Update result numbers
    const incorrectCount = actualTotalQuestions - correctAnswers;
    const accuracy = Math.round((correctAnswers / actualTotalQuestions) * 100);
    
    document.getElementById('correct-count').textContent = correctAnswers;
    document.getElementById('incorrect-count').textContent = incorrectCount;
    document.getElementById('accuracy').textContent = accuracy + '%';
    
    // Hide progress bar
    document.querySelector('.card.mb-4').style.display = 'none';

    // Populate comprehensive review section
    populateComprehensiveReview();

    // DON'T auto-submit - let user review first
    // Add a submit button instead
    addSubmitButton();
}

function populateComprehensiveReview(userAnswersData = null, quizDataParam = null) {
    const reviewContent = document.getElementById('review-content');
    if (!reviewContent) {
        console.error('review-content element not found!');
        return;
    }

    console.log('Starting populateComprehensiveReview');

    // Use provided data or try to get from various sources
    let actualUserAnswers = userAnswersData || window.userAnswers || userAnswers || {};
    let actualQuizData = quizDataParam || window.quizData || quizData || {};

    console.log('Raw userAnswers keys:', Object.keys(actualUserAnswers));
    console.log('Raw userAnswers:', actualUserAnswers);
    console.log('Raw quizData keys:', Object.keys(actualQuizData));

    // Check if the data structure is different than expected
    for (let key in actualUserAnswers) {
        console.log(`userAnswer[${key}]:`, actualUserAnswers[key]);
    }

    // Check if we have real quiz data
    if (!actualUserAnswers || Object.keys(actualUserAnswers).length === 0) {
        console.error('No quiz data found! Cannot populate comprehensive review.');
        reviewContent.innerHTML = '<div class="alert alert-warning"><strong>No quiz data available for review.</strong> Please try taking the quiz again.</div>';
        return;
    }

    let reviewHTML = '<div class="row">';
    let termCount = 0;

    // Collect all terms for review
    for (let questionId in actualUserAnswers) {
        console.log(`Processing question ${questionId}`);
        const answer = actualUserAnswers[questionId];
        const questionData = actualQuizData[questionId];

        console.log('Answer:', answer);
        console.log('Question data:', questionData);

        if (!answer || !questionData) {
            console.warn(`Missing data for question ${questionId}`);
            continue;
        }

        // Handle different data structures based on what was actually stored
        console.log(`Question ${questionId} condition check:`, answer.questionType === 'matching', !!(answer.termResults && questionData.terms));
        if (answer.questionType === 'matching' || (answer.termResults && questionData.terms)) {
            console.log(`Processing question ${questionId} as MATCHING`);
            // Add each term from matching questions - termResults can be array or object
            const termResults = answer.termResults;
            if (Array.isArray(termResults)) {
                // Handle array format
                for (let i = 0; i < termResults.length; i++) {
                    const termResult = termResults[i];

                    // For matching questions, terms are stored as strings in questionData.terms array
                    const termName = questionData.terms[i];
                    // Get the correct definition for this term
                    const correctDefIndex = questionData.correctMatches[i];
                    const correctDefinition = questionData.definitions[correctDefIndex];

                    reviewHTML += `
                        <div class="col-md-6 mb-3">
                            <div class="card h-100 ${termResult.isCorrect ? 'border-success' : 'border-danger'}">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <h6 class="card-title mb-1">
                                            <strong>${termName}</strong>
                                        </h6>
                                        <span class="badge ${termResult.isCorrect ? 'bg-success' : 'bg-danger'}">
                                            ${termResult.isCorrect ? '‚úì' : '‚úó'}
                                        </span>
                                    </div>
                                    <p class="card-text mb-2"><strong>Definition:</strong> ${correctDefinition}</p>

                                    ${termResult.isCorrect ?
                                        `<div class="alert alert-success p-2 mb-2">
                                            <small><strong>‚úì Correct Match:</strong> ${correctDefinition}</small>
                                        </div>` :
                                        `<div class="alert alert-danger p-2 mb-2">
                                            <small class="d-block"><strong>‚úó You matched with:</strong> ${questionData.definitions[termResult.userAnswer]}</small>
                                            <small class="d-block"><strong>‚úì Should be:</strong> ${correctDefinition}</small>
                                        </div>`
                                    }

                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">Matching</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    termCount++;
                    console.log(`Added matching term: ${termName}`);
                }
            } else if (typeof termResults === 'object' && termResults !== null) {
                // Handle object format (e.g., {0: {...}, 1: {...}, 2: {...}})
                for (let termIdx in termResults) {
                    const termResult = termResults[termIdx];
                    const termIndex = parseInt(termIdx);

                    // For matching questions, terms are stored as strings in questionData.terms array
                    const termName = questionData.terms[termIndex];
                    // Get the correct definition for this term
                    const correctDefIndex = questionData.correctMatches[termIndex];
                    const correctDefinition = questionData.definitions[correctDefIndex];

                    reviewHTML += `
                        <div class="col-md-6 mb-3">
                            <div class="card h-100 ${termResult.isCorrect ? 'border-success' : 'border-danger'}">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <h6 class="card-title mb-1">
                                            <strong>${termName}</strong>
                                        </h6>
                                        <span class="badge ${termResult.isCorrect ? 'bg-success' : 'bg-danger'}">
                                            ${termResult.isCorrect ? '‚úì' : '‚úó'}
                                        </span>
                                    </div>
                                    <p class="card-text mb-2"><strong>Definition:</strong> ${correctDefinition}</p>

                                    ${termResult.isCorrect ?
                                        `<div class="alert alert-success p-2 mb-2">
                                            <small><strong>‚úì Correct Match:</strong> ${correctDefinition}</small>
                                        </div>` :
                                        `<div class="alert alert-danger p-2 mb-2">
                                            <small class="d-block"><strong>‚úó You matched with:</strong> ${questionData.definitions[termResult.userAnswer]}</small>
                                            <small class="d-block"><strong>‚úì Should be:</strong> ${correctDefinition}</small>
                                        </div>`
                                    }

                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">Matching</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    termCount++;
                    console.log(`Added matching term: ${termName}`);
                }
            } else {
                console.warn('termResults is not an array or object:', termResults);
            }
        } else {
            // Handle different property names for non-matching questions
            console.log(`ENTERING NON-MATCHING BRANCH for question ${questionId}, questionType: ${questionData.questionType}`);
            const isCorrect = answer.isCorrect !== undefined ? answer.isCorrect : false;
            let userAnswerText = 'Not answered';
            let userSelectedIndex = answer.selected;

            // Extract term from question text for multiple choice/true-false
            let termName = 'Unknown term';
            let termDefinition = 'No definition available';
            let correctAnswerText = 'Unknown';

            // Try to extract from explanation - multiple patterns
            if (questionData.explanation) {
                // Pattern 1: "TRUE: 'term' does mean 'definition'"
                const trueMatch = questionData.explanation.match(/TRUE:\s*['"]([^'"]+)['"] does mean ['"]([^'"]+)['"]/);
                if (trueMatch) {
                    termName = trueMatch[1];
                    termDefinition = trueMatch[2];
                }

                // Pattern 2: "FALSE: 'term' actually means 'definition'"
                const falseMatch = questionData.explanation.match(/FALSE:\s*['"]([^'"]+)['"] actually means ['"]([^'"]+)['"]/);
                if (falseMatch) {
                    termName = falseMatch[1];
                    termDefinition = falseMatch[2];
                }

                // Pattern 3: "'term' means: definition" (original)
                const explMatch = questionData.explanation.match(/['"]([^'"]+)['"] means:\s*(.+)/);
                if (explMatch) {
                    termName = explMatch[1];
                    termDefinition = explMatch[2];
                }
            }

            // Debug what's actually in questionData
            console.log(`Question ${questionId} - questionData.explanation:`, questionData.explanation);

            // Extract term from explanation text since questionData.question is undefined
            if (questionData.explanation) {
                // First decode HTML entities for easier regex matching
                const decodedExplanation = questionData.explanation
                    .replace(/&#39;/g, "'")
                    .replace(/&quot;/g, '"')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>');

                console.log(`Decoded explanation: ${decodedExplanation}`);

                // For TF questions: "FALSE: 'taw' actually means..." or "TRUE: 'word' means..."
                const tfMatch = decodedExplanation.match(/(?:TRUE|FALSE):\s*'([^']+)'/);
                if (tfMatch) {
                    termName = tfMatch[1];
                    console.log(`TF term extracted from explanation: ${termName}`);
                }

                // For MC questions: "'kinderspiel' means: A dramatic piece..."
                const mcMatch = decodedExplanation.match(/'([^']+)'\s+means:/);
                if (mcMatch) {
                    termName = mcMatch[1];
                    console.log(`MC term extracted from explanation: ${termName}`);
                }

                // For the comprehensive review, we should use the actual definition from the database
                // rather than trying to parse it from explanation text
                if (questionData.wordId && termName) {
                    // Fetch the actual definition from the database
                    fetch(`/api/words/${questionData.wordId}`)
                        .then(response => response.json())
                        .then(data => {
                            termDefinition = data.word.definition;
                            console.log(`Fetched definition for ${termName}: ${termDefinition}`);
                            // Update the review display with the real definition
                            updateTermDefinitionInReview(questionId, termDefinition);
                        })
                        .catch(error => {
                            console.error(`Failed to fetch definition for ${termName}:`, error);
                            termDefinition = 'Definition unavailable';
                        });
                }
            } else {
                console.log(`Question ${questionId} - NO explanation available`);
            }

            // For multiple choice, try to get the answer text from various sources
            if (questionData.questionType === 'multiple_choice') {
                console.log(`Processing MC question ${questionId}, correctAnswer: ${questionData.correctAnswer}, userSelected: ${answer.selected}`);
                // If options array exists, use it
                if (questionData.options && questionData.correctAnswer !== undefined) {
                    correctAnswerText = questionData.options[questionData.correctAnswer];
                    if (answer.selected !== undefined && questionData.options) {
                        userAnswerText = questionData.options[answer.selected];
                    }
                    console.log(`Using options array: user="${userAnswerText}", correct="${correctAnswerText}"`);
                } else {
                    // Fallback: use simple text based on answer indices
                    correctAnswerText = `Answer choice ${questionData.correctAnswer}`;
                    if (answer.selected !== undefined) {
                        userAnswerText = `Answer choice ${answer.selected}`;
                    }
                    console.log(`Using fallback: user="${userAnswerText}", correct="${correctAnswerText}"`);
                }
            }

            // For true/false, correct answer is True/False
            if (questionData.questionType === 'true_false') {
                correctAnswerText = questionData.correctAnswer ? 'True' : 'False';
                userAnswerText = answer.selected ? 'True' : 'False';
                // termDefinition should already be set from explanation extraction above
            }

            // Add single term from other question types
            reviewHTML += `
                <div class="col-md-6 mb-3" data-question-id="${questionId}">
                    <div class="card h-100 ${isCorrect ? 'border-success' : 'border-danger'}">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="card-title mb-1">
                                    <strong>${termName}</strong>
                                </h6>
                                <span class="badge ${isCorrect ? 'bg-success' : 'bg-danger'}">
                                    ${isCorrect ? '‚úì' : '‚úó'}
                                </span>
                            </div>
                            <p class="card-text mb-2"><strong>Definition:</strong> <span class="definition-text">${termDefinition}</span></p>

                            ${!isCorrect ?
                                `<div class="alert alert-danger p-2 mb-2">
                                    <small class="d-block"><strong>‚úó Your answer:</strong> ${userAnswerText}</small>
                                    <small class="d-block"><strong>‚úì Correct answer:</strong> ${correctAnswerText}</small>
                                </div>` : ''
                            }

                            <div class="d-flex justify-content-between align-items-center">
                                <small class="text-muted">${questionData.questionType || questionData.question_type || 'QUESTION'}</small>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            termCount++;
            console.log(`Adding non-matching question ${questionId}: ${questionData?.term || 'unknown'}`);
        }
    }

    reviewHTML += '</div>';

    console.log(`Generated review HTML for ${termCount} terms:`, reviewHTML);

    if (termCount === 0) {
        reviewHTML = '<div class="alert alert-info">No quiz data available for review. Please try taking another quiz.</div>';
        console.warn('No terms found for review - showing fallback message');
    }

    reviewContent.innerHTML = reviewHTML;
    console.log('Review content populated successfully');
}

function updateTermDefinitionInReview(questionId, definition) {
    // Find the term card for this question and update its definition
    const reviewContent = document.getElementById('review-content');
    if (reviewContent) {
        // Look for definition text to update - use a more specific selector
        const definitionElement = reviewContent.querySelector(`[data-question-id="${questionId}"] .definition-text`);
        if (definitionElement) {
            definitionElement.textContent = definition;
            console.log(`Updated definition display for question ${questionId}`);
        } else {
            console.log(`Could not find definition element for question ${questionId}`);
        }
    }
}

function addSubmitButton() {
    // Add a button to submit results to server (optional)
    const resultsSection = document.getElementById('quiz-results');
    if (!resultsSection) return;

    // Check if button already exists
    if (document.getElementById('submit-results-btn')) return;

    // Create submit button container
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'text-center mt-4 mb-4';
    buttonContainer.innerHTML = `
        <button id="submit-results-btn" class="btn btn-primary btn-lg me-3" onclick="submitQuizResults()">
            üíæ Save Results & Continue
        </button>
        <button class="btn btn-outline-secondary" onclick="location.href='/quiz'">
            üîÑ Take Another Quiz
        </button>
        <button class="btn btn-outline-info" onclick="location.href='/'">
            üè† Back to Home
        </button>
    `;

    resultsSection.appendChild(buttonContainer);
}

function handleMatchingChange(selectElement) {
    const questionNum = parseInt(selectElement.dataset.question);
    const termIndex = parseInt(selectElement.dataset.termIndex);
    const selectedDefIndex = selectElement.value;
    
    console.log('Matching change:', questionNum, 'term:', termIndex, 'def:', selectedDefIndex);
    
    // Get all select elements for this question
    const allSelects = document.querySelectorAll(`select[data-question="${questionNum}"]`);
    
    // Check if all matches have been made
    let allMatched = true;
    const userMatches = {};
    
    allSelects.forEach(select => {
        const tIndex = parseInt(select.dataset.termIndex);
        const defIndex = select.value;
        
        if (defIndex === '') {
            allMatched = false;
        } else {
            userMatches[tIndex] = parseInt(defIndex);
        }
    });
    
    // If all matches are made, check correctness and enable next button
    if (allMatched) {
        const questionData = quizData[questionNum];
        const correctMatches = questionData.correctMatches;
        
        // Check if user matches are correct
        let isCorrect = true;
        for (let termIdx in userMatches) {
            if (userMatches[termIdx] !== correctMatches[termIdx]) {
                isCorrect = false;
                break;
            }
        }
        
        // Store the user's answer
        userAnswers[questionNum] = {
            matches: userMatches,
            isCorrect: isCorrect,
            questionType: 'matching'
        };
        
        // Enable next button
        const nextBtn = document.getElementById(`next-btn-${questionNum}`);
        if (nextBtn) {
            nextBtn.disabled = false;
            console.log('Next button enabled for question', questionNum);
        }
        
        // Visual feedback for matches
        allSelects.forEach(select => {
            const tIndex = parseInt(select.dataset.termIndex);
            const userDefIndex = userMatches[tIndex];
            const correctDefIndex = correctMatches[tIndex];
            
            // Add visual feedback classes
            const termCard = select.closest('.term-item');
            if (userDefIndex === correctDefIndex) {
                termCard.classList.add('border-success');
                termCard.classList.remove('border-danger');
                select.classList.add('text-success');
            } else {
                termCard.classList.add('border-danger');
                termCard.classList.remove('border-success');
                select.classList.add('text-danger');
            }
        });
    } else {
        // Disable next button if not all matches are made
        const nextBtn = document.getElementById(`next-btn-${questionNum}`);
        if (nextBtn) {
            nextBtn.disabled = true;
        }
    }
}

function submitQuizResults() {
    // Calculate actual total questions including individual terms in matching questions
    let actualTotalQuestions = 0;
    for (let i = 1; i <= totalQuestions; i++) {
        if (userAnswers[i] && userAnswers[i].questionType === 'matching') {
            actualTotalQuestions += userAnswers[i].totalTermCount;
        } else {
            actualTotalQuestions += 1; // Regular question counts as 1
        }
    }

    // Prepare results data
    const questionResults = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Create one result record per term in matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                questionResults.push({
                    word_id: questionData.words[termIdx].id, // Get specific word ID for this term
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    response_time_ms: answer.responseTime || 3000,
                    chosen_distractor_id: null, // Matching doesn't use distractor IDs
                    user_answer: termResult.userAnswer,
                    correct_answer: termResult.correctAnswer
                });
            }
        } else {
            // Handle regular questions as before
            questionResults.push({
                word_id: questionData.wordId,
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                response_time_ms: answer.responseTime || 3000,
                chosen_distractor_id: answer.isCorrect ? null : (answer.chosenDistractorId ? parseInt(answer.chosenDistractorId) : null)
            });
        }
    }
    
    // Collect all terms for comprehensive review
    const allTermsReview = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Add each term from matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                const termData = questionData.words[termIdx];
                allTermsReview.push({
                    term: termData.term,
                    definition: termData.definition,
                    part_of_speech: termData.part_of_speech || 'NOUN',
                    domain: termData.domain || '',
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    user_answer: questionData.definitions[termResult.userAnswer] || '',
                    correct_answer: questionData.definitions[termResult.correctAnswer] || ''
                });
            }
        } else {
            // Add single term from other question types
            allTermsReview.push({
                term: questionData.term,
                definition: questionData.definition,
                part_of_speech: questionData.part_of_speech || 'NOUN',
                domain: questionData.domain || '',
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                user_answer: answer.selectedOption || '',
                correct_answer: questionData.correctAnswer || ''
            });
        }
    }

    const resultsData = {
        correctCount: correctAnswers,
        totalQuestions: actualTotalQuestions,
        accuracy: Math.round((correctAnswers / actualTotalQuestions) * 100),
        difficulty: "{{ difficulty }}",
        quizType: "{{ quiz_type }}",
        score: Math.round((correctAnswers / actualTotalQuestions) * 100),
        questions: questionResults,
        reviewData: allTermsReview
    };
    
    // Submit via form
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = '/quiz/submit';
    form.style.display = 'none';
    
    const sessionInput = document.createElement('input');
    sessionInput.name = 'session_id';
    sessionInput.value = sessionId;
    form.appendChild(sessionInput);
    
    const resultsInput = document.createElement('input');
    resultsInput.name = 'results';
    resultsInput.value = JSON.stringify(resultsData);
    form.appendChild(resultsInput);
    
    document.body.appendChild(form);
    form.submit();
}

// Enable next button when option is selected
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio') {
        const questionNum = parseInt(e.target.dataset.question);
        console.log('Radio change event:', questionNum, 'current:', currentQuestion);
        if (questionNum === currentQuestion) {
            const nextBtn = document.getElementById(`next-btn-${questionNum}`);
            if (nextBtn) {
                nextBtn.disabled = false;
                console.log('Next button enabled for question', questionNum);
            }
        }
    }
});

// Also add click event listener as backup
document.addEventListener('click', function(e) {
    if (e.target.type === 'radio') {
        const questionNum = parseInt(e.target.dataset.question);
        if (questionNum === currentQuestion) {
            const nextBtn = document.getElementById(`next-btn-${questionNum}`);
            if (nextBtn) {
                nextBtn.disabled = false;
            }
        }
    }
});

// Drag and Drop Functionality for Matching Questions
let draggedElement = null;
let draggedFromTermSlot = null;

function initializeMatchingQuestions() {
    // Add event listeners to draggable definitions
    document.querySelectorAll('.draggable').forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
    });
    
    // Add event listeners to drop zones (term slots)
    document.querySelectorAll('.drop-zone').forEach(dropZone => {
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('drop', handleDrop);
        dropZone.addEventListener('click', handleDropZoneClick);
    });
    
    // CRITICAL: Add event listeners to definitions banks (to allow dropping back)
    document.querySelectorAll('.definitions-bank').forEach(bank => {
        bank.addEventListener('dragover', handleDragOver);
        bank.addEventListener('drop', handleDropToBank);
    });
    
    // Initialize matching state for all visible matching questions
    document.querySelectorAll('.matching-container').forEach(container => {
        const questionId = container.closest('[data-question]').dataset.question;
        if (questionId) {
            checkMatchingCompletion(questionId);
            
            // If question is already answered, disable all drag interactions
            if (isQuestionAnswered(questionId)) {
                disableMatchingInteractions(questionId);
            }
        }
    });
}

function handleDragStart(e) {
    if (e.target.classList.contains('definition-item')) {
        // Check if this question already has feedback displayed (already answered)
        const questionElement = e.target.closest('[data-question]') || document;
        const questionId = questionElement.dataset.question;
        
        if (isQuestionAnswered(questionId)) {
            // Prevent dragging on answered questions
            e.preventDefault();
            return false;
        }
        
        draggedElement = e.target;
        e.target.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', ''); // Required for some browsers
        
        // Check if dragging from a term slot
        const termSlot = e.target.closest('.term-slot');
        if (termSlot) {
            draggedFromTermSlot = termSlot;
        } else {
            draggedFromTermSlot = null;
        }
        
        // Add visual feedback
        document.querySelectorAll('.drop-zone').forEach(zone => {
            zone.classList.add('drag-active');
        });
    }
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    // Add visual feedback for valid drop target
    if (e.currentTarget.classList.contains('drop-zone')) {
        e.currentTarget.classList.add('drag-over');
    }
}

function handleDrop(e) {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    
    if (draggedElement && e.currentTarget.classList.contains('drop-zone')) {
        const dropZone = e.currentTarget.querySelector('.definition-drop-area');
        const termSlot = e.currentTarget.closest('.term-slot');
        
        // If there's already a definition in this slot, move it back to definitions bank
        const existingDef = dropZone.querySelector('.definition-item');
        if (existingDef) {
            moveDefinitionToBank(existingDef);
        }
        
        // Move the dragged element to this drop zone
        dropZone.innerHTML = '';
        const clonedElement = draggedElement.cloneNode(true);
        clonedElement.style.cursor = 'pointer';
        
        // CRITICAL: Add drag event listeners to cloned element so it can be dragged back
        clonedElement.addEventListener('dragstart', handleDragStart);
        clonedElement.addEventListener('dragend', handleDragEnd);
        
        dropZone.appendChild(clonedElement);
        
        // If dragging from definitions bank, hide original
        if (!draggedFromTermSlot) {
            draggedElement.style.display = 'none';
        } else {
            // If dragging from another term slot, clear that slot
            const originalDropArea = draggedFromTermSlot.querySelector('.definition-drop-area');
            originalDropArea.innerHTML = '<span class="drop-placeholder text-muted" style="font-style: italic; font-size: 0.9em;">Drop definition here...</span>';
        }
        
        // Update the hidden input for this term
        const termIndex = termSlot.dataset.termIndex;
        const defIndex = draggedElement.dataset.defIndex;
        const questionId = termSlot.dataset.question;
        const hiddenInput = termSlot.querySelector('.term-match-input');
        if (hiddenInput) {
            hiddenInput.value = defIndex;
        }
        
        // Check if matching is complete
        checkMatchingCompletion(questionId);
    }
}

function handleDragEnd(e) {
    e.target.style.opacity = '1';
    
    // Remove drag indicators
    document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.classList.remove('drag-active', 'drag-over');
    });
    
    draggedElement = null;
    draggedFromTermSlot = null;
}

function moveDefinitionToBank(defElement) {
    const defIndex = defElement.dataset.defIndex;
    const questionId = defElement.dataset.question;
    const definitionsBank = document.getElementById(`definitions-bank-${questionId}`);
    
    // Find the original definition in the bank and show it
    const originalDef = definitionsBank.querySelector(`[data-def-index="${defIndex}"]`);
    if (originalDef) {
        originalDef.style.display = 'block';
    }
}

function handleDropZoneClick(e) {
    // Allow clicking on a definition in a term slot to remove it
    const clickedDef = e.target.closest('.definition-item');
    if (clickedDef) {
        const termSlot = e.currentTarget.closest('.term-slot') || e.target.closest('.term-slot');
        const questionId = termSlot.dataset.question;
        
        // Check if this question already has feedback displayed (already answered)
        if (isQuestionAnswered(questionId)) {
            // Prevent click-to-remove on answered questions
            return false;
        }
        
        const dropArea = termSlot.querySelector('.definition-drop-area');
        
        // Clear any feedback styling first
        termSlot.classList.remove('border-success', 'border-danger', 'border-warning');
        termSlot.style.backgroundColor = '';
        
        // Move definition back to bank
        moveDefinitionToBank(clickedDef);
        
        // Clear the drop area
        dropArea.innerHTML = '<span class="drop-placeholder text-muted" style="font-style: italic; font-size: 0.9em;">Drop definition here...</span>';
        
        // Clear the hidden input
        const hiddenInput = termSlot.querySelector('.term-match-input');
        if (hiddenInput) {
            hiddenInput.value = '';
        }
        
        // Check completion status and update Next button
        checkMatchingCompletion(questionId);
        
        console.log('Definition removed from term slot');
    }
}

function handleDropToBank(e) {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    
    if (draggedElement && draggedFromTermSlot) {
        // Only allow dropping back to bank if dragged from a term slot
        const defIndex = draggedElement.dataset.defIndex;
        const questionId = draggedElement.dataset.question;
        
        // Clear the original term slot
        const originalDropArea = draggedFromTermSlot.querySelector('.definition-drop-area');
        originalDropArea.innerHTML = '<span class="drop-placeholder text-muted" style="font-style: italic; font-size: 0.9em;">Drop definition here...</span>';
        
        // Clear the hidden input
        const hiddenInput = draggedFromTermSlot.querySelector('.term-match-input');
        if (hiddenInput) {
            hiddenInput.value = '';
        }
        
        // Clear any feedback styling from the term slot
        draggedFromTermSlot.classList.remove('border-success', 'border-danger', 'border-warning');
        draggedFromTermSlot.style.backgroundColor = '';
        
        // Show the original definition in the bank
        const definitionsBank = document.getElementById(`definitions-bank-${questionId}`);
        const originalDef = definitionsBank.querySelector(`[data-def-index="${defIndex}"]`);
        if (originalDef) {
            originalDef.style.display = 'block';
        }
        
        // Update completion status
        checkMatchingCompletion(questionId);
        
        console.log('Definition dragged back to bank');
    }
    
    // Reset drag state
    draggedElement = null;
    draggedFromTermSlot = null;
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.definition-item:not(.opacity-50)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function updateMatchingInputs(questionId) {
    const container = document.getElementById(`definitions-sortable-${questionId}`);
    const definitionItems = container.querySelectorAll('.definition-item');
    
    definitionItems.forEach((item, newIndex) => {
        const originalIndex = item.dataset.originalIndex;
        const input = item.querySelector('.match-input');
        if (input) {
            // Update the hidden input to reflect new position
            input.value = newIndex; // This represents which term position this definition matches
        }
        
        // Update visual indicator
        const badge = item.querySelector('.definition-number');
        if (badge) {
            badge.textContent = newIndex + 1;
        }
    });
}

function isQuestionAnswered(questionId) {
    // Return true if there's any feedback element that was created after completing the question
    
    const questionElement = document.querySelector(`[data-question="${questionId}"]`) || document;
    
    // Look for the specific feedback div that gets added after completing a matching question
    const specificFeedback = questionElement.querySelector('.feedback-message');
    if (specificFeedback && (specificFeedback.textContent.includes('Perfect!') || specificFeedback.textContent.includes('Result:'))) {
        return true;
    }
    
    // Look for alert elements that might contain feedback (including partial scores)
    const alertElements = questionElement.querySelectorAll('.alert-success, .alert-info, .alert-warning');
    for(let alert of alertElements) {
        // Check for any result feedback, not just perfect scores
        if (alert.textContent.includes('Perfect!') || 
            alert.textContent.includes('You matched all') || 
            alert.textContent.includes('Result:') ||
            alert.textContent.includes('correct matches')) {
            return true;
        }
    }
    
    return false;
}

function disableMatchingInteractions(questionId) {
    // Disable all drag and drop interactions for answered questions
    const questionElement = document.querySelector(`[data-question="${questionId}"]`);
    if (!questionElement) return;
    
    // Make all definitions non-draggable
    questionElement.querySelectorAll('.definition-item').forEach(item => {
        item.draggable = false;
        item.style.cursor = 'default';
        item.style.opacity = '0.8';
    });
    
    // Disable drop zones
    questionElement.querySelectorAll('.drop-zone').forEach(zone => {
        zone.style.pointerEvents = 'none';
    });
    
    console.log(`Disabled interactions for answered question ${questionId}`);
}

function checkMatchingCompletion(questionId) {
    const termSlots = document.querySelectorAll(`.term-slot[data-question="${questionId}"]`);
    let filledSlots = 0;
    
    // Count how many term slots have definitions
    termSlots.forEach(slot => {
        const hiddenInput = slot.querySelector('.term-match-input');
        if (hiddenInput && hiddenInput.value !== '') {
            filledSlots++;
        }
    });
    
    // Check if feedback is already displayed (question already answered)
    const hasFeedback = isQuestionAnswered(questionId);
    
    // Enable next button if all slots are filled OR if feedback is already shown
    const nextBtn = document.getElementById(`next-btn-${questionId}`);
    if (nextBtn) {
        // If feedback is shown, always enable the button (question is already answered)
        if (hasFeedback) {
            nextBtn.disabled = false;
        } else {
            // Only check slot completion for unanswered questions
            nextBtn.disabled = filledSlots < termSlots.length;
        }
        console.log(`Matching completion: ${filledSlots}/${termSlots.length} slots filled, feedback shown: ${hasFeedback}, button disabled: ${nextBtn.disabled}`);
    }
    
    // Provide visual feedback about current matches if all filled
    if (filledSlots === termSlots.length) {
        validateCurrentMatches(questionId);
    }
}

function validateCurrentMatches(questionId) {
    const termSlots = document.querySelectorAll(`.term-slot[data-question="${questionId}"]`);
    const questionData = quizData[questionId];
    if (!questionData || !questionData.correctMatches) return;
    
    let correctCount = 0;
    
    termSlots.forEach(slot => {
        const termIndex = parseInt(slot.dataset.termIndex);
        const hiddenInput = slot.querySelector('.term-match-input');
        const userDefIndex = hiddenInput ? parseInt(hiddenInput.value) : -1;
        const correctDefIndex = questionData.correctMatches[termIndex];
        
        // Remove existing feedback classes
        slot.classList.remove('border-success', 'border-warning', 'border-danger');
        
        if (userDefIndex === correctDefIndex) {
            slot.classList.add('border-success');
            correctCount++;
        } else {
            slot.classList.add('border-warning');
        }
    });
    
    console.log(`Matching validation: ${correctCount}/${termSlots.length} correct`);
}

function showMatchingFeedback(questionId, userMatches, correctMatches, termResults, correctTermCount, totalTermCount) {
    const termSlots = document.querySelectorAll(`.term-slot[data-question="${questionId}"]`);
    const questionData = quizData[questionId];

    // Show which matches were correct/incorrect with stronger visual feedback
    termSlots.forEach(slot => {
        const termIndex = parseInt(slot.dataset.termIndex);
        const termResult = termResults[termIndex];

        // Remove existing feedback classes
        slot.classList.remove('border-success', 'border-warning', 'border-danger');

        if (termResult && termResult.isCorrect) {
            slot.classList.add('border-success');
            slot.style.backgroundColor = '#d4edda';

            // Add checkmark or success indicator
            let successIcon = slot.querySelector('.match-result-icon');
            if (!successIcon) {
                successIcon = document.createElement('span');
                successIcon.className = 'match-result-icon badge bg-success ms-2';
                successIcon.textContent = '‚úì';
                slot.appendChild(successIcon);
            }
        } else {
            slot.classList.add('border-danger');
            slot.style.backgroundColor = '#f8d7da';

            // Add X or error indicator
            let errorIcon = slot.querySelector('.match-result-icon');
            if (!errorIcon) {
                errorIcon = document.createElement('span');
                errorIcon.className = 'match-result-icon badge bg-danger ms-2';
                errorIcon.textContent = '‚úó';
                slot.appendChild(errorIcon);
            }
        }
    });

    // Show overall feedback message
    const container = document.querySelector(`.matching-container[data-question="${questionId}"]`) ||
                      document.querySelector(`[data-question="${questionId}"] .matching-container`);

    if (container) {
        // Remove existing feedback
        const existingFeedback = container.querySelector('.matching-feedback');
        if (existingFeedback) {
            existingFeedback.remove();
        }

        // Add feedback message
        const feedbackDiv = document.createElement('div');
        const isPerfect = correctTermCount === totalTermCount;
        feedbackDiv.className = `matching-feedback alert mt-3 ${isPerfect ? 'alert-success' : 'alert-info'}`;

        if (isPerfect) {
            feedbackDiv.innerHTML = `<strong>üéâ Perfect!</strong> You matched all ${totalTermCount} terms correctly!`;
        } else {
            const percentage = Math.round((correctTermCount / totalTermCount) * 100);
            feedbackDiv.innerHTML = `
                <strong>üìä Result:</strong> ${correctTermCount}/${totalTermCount} correct matches (${percentage}%)
                <br><small class="text-muted">
                    <span class="text-success">‚úì Green borders</span> show correct matches,
                    <span class="text-danger">‚úó red borders</span> show incorrect ones.
                </small>
            `;
        }
        
        container.appendChild(feedbackDiv);
        
        // CRITICAL: Ensure Next button stays functional after feedback
        const nextBtn = document.querySelector(`[data-question="${questionId}"] button[id*="next"]`) || 
                         document.querySelector('button:contains("Next")') ||
                         document.querySelector('button[onclick*="next"]') ||
                         document.querySelector('.btn:contains("Next ‚Üí")');
        
        if (nextBtn) {
            nextBtn.disabled = false;
            nextBtn.style.pointerEvents = 'auto';
            console.log('Next button re-enabled after feedback');
        }
    }
}

// Replace the old handleMatchingChange function
function handleMatchingChange() {
    // This function is no longer needed with drag-and-drop
    // but keeping it to prevent errors from old calls
    console.log('handleMatchingChange called - using drag-and-drop instead');
}

// Initialize drag-and-drop when page loads
document.addEventListener('DOMContentLoaded', function() {
    initializeMatchingQuestions();
    setupFeedbackObserver();
    setupMatchingCompletionMonitor();
});

// Set up MutationObserver to watch for feedback elements being added
function setupFeedbackObserver() {
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            // Check for added nodes that might be feedback elements
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    // Check if this is a feedback element
                    if (node.classList && (
                        node.classList.contains('matching-feedback') ||
                        node.classList.contains('alert-success') ||
                        node.classList.contains('alert-warning') ||
                        node.classList.contains('alert-info') ||
                        node.classList.contains('feedback-message')
                    )) {
                        // Find the question this feedback belongs to
                        const questionElement = node.closest('[data-question]');
                        if (questionElement) {
                            const questionId = questionElement.dataset.question;
                            console.log('Feedback detected for question', questionId, 'by MutationObserver');
                            
                            // Small delay to ensure DOM is settled, then check completion
                            setTimeout(() => {
                                checkMatchingCompletion(questionId);
                            }, 50);
                        }
                    }
                    
                    // Also check if any child elements are feedback elements
                    const feedbackChildren = node.querySelectorAll && node.querySelectorAll('.matching-feedback, .alert-success, .alert-warning, .alert-info, .feedback-message');
                    if (feedbackChildren && feedbackChildren.length > 0) {
                        feedbackChildren.forEach(function(feedbackChild) {
                            const questionElement = feedbackChild.closest('[data-question]');
                            if (questionElement) {
                                const questionId = questionElement.dataset.question;
                                console.log('Feedback child detected for question', questionId, 'by MutationObserver');
                                
                                setTimeout(() => {
                                    checkMatchingCompletion(questionId);
                                }, 50);
                            }
                        });
                    }
                }
            });
            
            // Also check for text changes that might indicate feedback
            if (mutation.type === 'childList' && mutation.target.classList && 
                (mutation.target.classList.contains('alert') || 
                 mutation.target.classList.contains('feedback-message'))) {
                const questionElement = mutation.target.closest('[data-question]');
                if (questionElement) {
                    const questionId = questionElement.dataset.question;
                    console.log('Feedback text change detected for question', questionId, 'by MutationObserver');
                    
                    setTimeout(() => {
                        checkMatchingCompletion(questionId);
                    }, 50);
                }
            }
        });
    });
    
    // Start observing the entire quiz container for changes
    const quizContainer = document.getElementById('quiz-container');
    if (quizContainer) {
        observer.observe(quizContainer, {
            childList: true,
            subtree: true,
            attributes: false,
            characterData: true
        });
        console.log('Feedback MutationObserver initialized');
    }
}

// Set up continuous monitoring for matching completion
function setupMatchingCompletionMonitor() {
    let lastCheckedQuestion = null;
    
    // Check for matching completion every 500ms
    setInterval(function() {
        // Get the currently visible question
        const visibleQuestion = document.querySelector('[data-question]:not([style*="display: none"])');
        if (!visibleQuestion) return;
        
        const questionId = visibleQuestion.dataset.question;
        const questionData = quizData[questionId];
        
        // Only check matching questions
        if (!questionData || questionData.questionType !== 'matching') return;
        
        // Check if this is a new question or if we need to recheck
        const shouldCheck = lastCheckedQuestion !== questionId || isQuestionAnswered(questionId);
        
        if (shouldCheck) {
            // Check if button is disabled but question is answered
            const nextBtn = document.getElementById(`next-btn-${questionId}`);
            const hasAnswers = isQuestionAnswered(questionId);
            
            if (nextBtn && nextBtn.disabled && hasAnswers) {
                console.log(`Background monitor: fixing disabled button for answered question ${questionId}`);
                checkMatchingCompletion(questionId);
            }
            
            lastCheckedQuestion = questionId;
        }
    }, 500);
    
    console.log('Matching completion background monitor initialized');
}

// Initialize
updateProgress();
</script>

<style>
/* ========================================
   ENHANCED QUIZ INTERFACE STYLES
   ======================================== */

/* Enhanced Quiz Progress */
.quiz-progress-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-left: 4px solid var(--color-primary) !important;
}

.quiz-progress-info h4 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.progress-percentage {
    font-size: 1.1rem;
    font-weight: 600;
}

.quiz-progress-steps {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #e2e8f0;
}

.progress-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
}

.step-circle {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #e2e8f0;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.progress-step.completed .step-circle {
    background-color: var(--color-primary);
    color: white;
}

.progress-step.current .step-circle {
    background-color: var(--color-primary);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}

/* Enhanced Question Cards */
.question-card {
    border-radius: 16px !important;
}

.question-header {
    border-bottom: 2px solid #f1f5f9;
    padding-bottom: 1.5rem;
}

.question-type-label {
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.question-word-highlight {
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    padding: 1rem 1.5rem;
    border-radius: 12px;
    border-left: 4px solid var(--color-primary);
}

.featured-word {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-primary);
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    padding: 0 0.5rem;
}

.definition-block {
    margin-top: 1.5rem;
}

.definition-quote {
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 1.5rem;
    margin: 0;
    position: relative;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
}

.definition-quote::before {
    content: '\201C';
    font-size: 3rem;
    color: var(--color-primary);
    position: absolute;
    top: -0.5rem;
    left: 1rem;
    line-height: 1;
}

.definition-text {
    font-size: 1.1rem;
    line-height: 1.6;
    color: #374151;
    margin: 0;
    padding-left: 2rem;
}

/* Enhanced Multiple Choice Options */
.options-container {
    margin-top: 2rem;
}

.option-card {
    transition: all 0.2s ease;
}

.option-label {
    display: block;
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.option-label:hover {
    border-color: var(--color-primary);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(37, 99, 235, 0.15);
}

.option-content {
    display: flex;
    align-items: flex-start;
    padding: 1.25rem;
    gap: 1rem;
}

.option-letter {
    width: 32px;
    height: 32px;
    background: var(--color-primary);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 0.9rem;
    flex-shrink: 0;
}

.option-text {
    flex: 1;
    min-width: 0;
}

.option-main {
    font-size: 1rem;
    line-height: 1.5;
    color: #374151;
    font-weight: 500;
    margin-bottom: 0.5rem;
}

.option-details {
    font-size: 0.9rem;
    line-height: 1.4;
    color: #6b7280;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.detail-item {
    padding: 0.25rem 0.5rem;
    background: #f9fafb;
    border-radius: 6px;
    border: 1px solid #e5e7eb;
}

.option-selector {
    flex-shrink: 0;
    margin-top: 0.25rem;
}

.radio-circle {
    width: 20px;
    height: 20px;
    border: 2px solid #d1d5db;
    border-radius: 50%;
    transition: all 0.2s ease;
    position: relative;
}

.radio-circle::after {
    content: '';
    width: 8px;
    height: 8px;
    background: var(--color-primary);
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.2s ease;
}

/* Selected state */
input[type="radio"]:checked + .option-label {
    border-color: var(--color-primary);
    background: rgba(37, 99, 235, 0.02);
}

input[type="radio"]:checked + .option-label .option-letter {
    background: var(--color-primary);
    transform: scale(1.1);
}

input[type="radio"]:checked + .option-label .radio-circle {
    border-color: var(--color-primary);
}

input[type="radio"]:checked + .option-label .radio-circle::after {
    transform: translate(-50%, -50%) scale(1);
}

/* Enhanced True/False Options */
.true-false-container {
    margin-top: 2rem;
}

.tf-option-card {
    height: 100%;
    transition: all 0.2s ease;
}

.tf-option-label {
    display: block;
    height: 100%;
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.tf-option-label:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
}

.true-option .tf-option-label:hover {
    border-color: #10b981;
    box-shadow: 0 12px 30px rgba(16, 185, 129, 0.2);
}

.false-option .tf-option-label:hover {
    border-color: #ef4444;
    box-shadow: 0 12px 30px rgba(239, 68, 68, 0.2);
}

.tf-option-content {
    padding: 2rem 1.5rem;
    text-align: center;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.tf-icon {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #6b7280;
    transition: all 0.2s ease;
}

.true-option .tf-icon {
    color: #10b981;
}

.false-option .tf-icon {
    color: #ef4444;
}

.tf-text {
    font-size: 1.5rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 0.5rem;
}

.tf-description {
    font-size: 0.9rem;
    color: #6b7280;
    line-height: 1.4;
}

/* Selected True/False state */
input[type="radio"]:checked + .tf-option-label {
    background: rgba(37, 99, 235, 0.05);
    border-color: var(--color-primary);
}

.true-option input[type="radio"]:checked + .tf-option-label {
    background: rgba(16, 185, 129, 0.05);
    border-color: #10b981;
}

.false-option input[type="radio"]:checked + .tf-option-label {
    background: rgba(239, 68, 68, 0.05);
    border-color: #ef4444;
}

input[type="radio"]:checked + .tf-option-label .tf-icon {
    transform: scale(1.2);
}

/* Enhanced Feedback */
.feedback-card {
    border-radius: 12px;
    overflow: hidden;
    animation: fadeInUp 0.4s ease-out;
}

.feedback-header {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    padding: 1.5rem;
}

.feedback-icon {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: bold;
    flex-shrink: 0;
}

.feedback-content {
    flex: 1;
}

.feedback-result {
    font-size: 1.2rem;
    font-weight: 600;
    margin: 0;
}

.feedback-explanation {
    color: #6b7280;
    line-height: 1.5;
    margin-top: 0.5rem;
}

/* Correct feedback styling */
.alert-success .feedback-card {
    background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
    border: 2px solid #10b981;
}

.alert-success .feedback-icon {
    background: #10b981;
    color: white;
}

.alert-success .feedback-icon::before {
    content: '‚úì';
}

.alert-success .feedback-result {
    color: #065f46;
}

/* Incorrect feedback styling */
.alert-danger .feedback-card {
    background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
    border: 2px solid #ef4444;
}

.alert-danger .feedback-icon {
    background: #ef4444;
    color: white;
}

.alert-danger .feedback-icon::before {
    content: '‚úó';
}

.alert-danger .feedback-result {
    color: #991b1b;
}

/* Enhanced Navigation */
.quiz-navigation {
    border-top: 2px solid #f1f5f9;
    padding-top: 2rem;
}

.navigation-help {
    font-style: italic;
}

/* Animations */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .quiz-progress-visual {
        text-align: center !important;
        margin-top: 1rem;
    }

    .quiz-progress-card .d-flex {
        flex-direction: column;
        align-items: stretch !important;
    }

    .quiz-progress-steps {
        overflow-x: auto;
        padding-bottom: 0.5rem;
    }

    .quiz-progress-steps .d-flex {
        min-width: max-content;
    }

    .question-word-highlight {
        padding: 0.75rem 1rem;
    }

    .featured-word {
        font-size: 1.25rem;
        display: block;
        margin: 0.5rem 0;
    }

    .definition-text {
        font-size: 1rem;
        padding-left: 1rem;
    }

    .option-content {
        padding: 1rem;
    }

    .option-details {
        flex-direction: column;
        gap: 0.5rem;
    }

    .detail-item {
        display: block;
        width: 100%;
        text-align: left;
    }

    .tf-option-content {
        padding: 1.5rem 1rem;
    }

    .quiz-navigation .d-flex {
        flex-direction: column;
        gap: 1rem;
    }

    .navigation-help {
        order: -1;
    }
}

/* Drag and Drop Styling for Matching Questions */
.matching-container .definition-item {
    transition: all 0.3s ease;
    cursor: move;
}

.matching-container .definition-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.matching-container .definition-item.drag-drop-target {
    background-color: #f8f9fa;
    border: 2px dashed #007bff;
}

.matching-container .drag-handle {
    cursor: grab;
    opacity: 0.6;
}

.matching-container .drag-handle:active {
    cursor: grabbing;
}

.matching-container .definition-item[draggable="true"]:hover .drag-handle {
    opacity: 1;
}

.matching-instructions {
    border-left: 4px solid #007bff;
}

.term-slot {
    background-color: #f8f9fa;
}

/* Responsive matching layout */
@media (max-width: 991px) {
    .matching-container .col-lg-7,
    .matching-container .col-lg-5 {
        margin-bottom: 2rem;
    }
}

/* Compact term slots for better space usage */
.term-slot .term-text {
    min-width: 120px;
    max-width: 150px;
}

.definition-drop-area {
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.3;
}

/* More compact definitions bank */
.definitions-bank {
    max-height: 60vh;
    overflow-y: auto;
    padding: 10px;
    border: 2px dashed transparent;
    border-radius: 8px;
    transition: all 0.3s ease;
}

/* Visual feedback when dragging over definitions bank */
.definitions-bank.drag-over {
    border-color: #28a745;
    background-color: #f8fff9;
}

.definitions-bank .definition-item {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.definitions-bank .definition-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.definition-number {
    min-width: 24px;
    text-align: center;
}

.term-number {
    min-width: 24px;
    text-align: center;
}

/* Enhanced drag and drop feedback */
.drop-zone.drag-active {
    border-color: #007bff !important;
    background-color: #e3f2fd !important;
}

.drop-zone.drag-over {
    border-color: #28a745 !important;
    background-color: #d4edda !important;
}

.definition-drop-area {
    transition: all 0.3s ease;
}

.term-slot.border-success {
    border-color: #28a745 !important;
}

.term-slot.border-warning {
    border-color: #ffc107 !important;
}

.definition-item .definition-content {
    pointer-events: none; /* Ensure drag events work properly */
}
</style>
{% endblock %}