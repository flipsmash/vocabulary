{% extends "base.html" %}

{% block title %}Quiz Session{% endblock %}

{% block extra_head %}
<!-- React and React-DOM -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<!-- Our compiled React component -->
<script src="/static/js/matching-quiz.js"></script>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row justify-content-center">
        <div class="col-12">
            <!-- Enhanced Quiz Progress -->
            <div class="quiz-progress-card card mb-4 border-0 shadow-sm">
                <div class="card-body py-4">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div class="quiz-progress-info">
                            <h4 class="mb-1 text-primary">Question <span id="current-question" class="fw-bold">1</span> of {{ questions|length }}</h4>
                            <div class="d-flex align-items-center gap-2">
                                <span class="badge bg-light text-dark px-3 py-2">{{ difficulty|title }} difficulty</span>
                                <span class="text-muted small">Mixed question types</span>
                            </div>
                        </div>
                        <div class="quiz-progress-visual text-end">
                            <div class="progress-percentage text-primary fw-bold mb-1" id="progress-percentage">0%</div>
                            <div class="progress" style="width: 240px; height: 12px; border-radius: 6px;">
                                <div class="progress-bar bg-primary" id="progress-bar" role="progressbar" style="width: 0%; border-radius: 6px; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="quiz-progress-steps d-flex justify-content-between">
                        {% for i in range(1, questions|length + 1) %}
                        <div class="progress-step" data-step="{{ i }}">
                            <div class="step-circle">{{ i }}</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            
            <!-- Quiz Questions -->
            <div id="quiz-container">
                {% for question in questions %}
                <div class="question-card card mb-4 border-0 shadow-sm" data-question="{{ question.id }}" {% if question.id != 1 %}style="display: none;"{% endif %}>
                    <div class="card-body p-5">
                        <!-- Question Header with improved typography -->
                        <div class="question-header mb-4">
                            {% if question.question_type == "true_false" %}
                                {% set question_parts = question.question.split("'") %}
                                {% if question_parts|length >= 3 %}
                                <div class="question-statement">
                                    <h3 class="question-type-label text-primary mb-3">üìù True or False</h3>
                                    <div class="question-word-highlight mb-3">
                                        <span class="question-prefix text-muted">Does the word</span>
                                        <span class="featured-word">"{{ question_parts[1] }}"</span>
                                        <span class="question-suffix text-muted">mean:</span>
                                    </div>
                                    <div class="definition-block">
                                        {% set definition_part = question.question.split("means '")[1].rstrip("' ") if "means '" in question.question else question.question.split("'")[-2] %}
                                        <blockquote class="definition-quote">
                                            <p class="definition-text">{{ definition_part }}</p>
                                        </blockquote>
                                    </div>
                                </div>
                                {% else %}
                                <h3 class="question-title">{{ question.question }}</h3>
                                {% endif %}
                            {% elif question.question_type == "multiple_choice" %}
                                <h3 class="question-type-label text-primary mb-3">üéØ Multiple Choice</h3>
                                <h4 class="question-title">{{ question.question }}</h4>
                            {% else %}
                                <h4 class="question-title">{{ question.question }}</h4>
                            {% endif %}
                        </div>
                        
                        <!-- Question Options -->
                        <div class="options mt-4">
                            {% if question.question_type == "true_false" %}
                            <!-- Enhanced True/False Options -->
                            <div class="true-false-container">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <div class="tf-option-card true-option">
                                            <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                                   id="option_{{ question.id }}_true" value="true"
                                                   data-question="{{ question.id }}">
                                            <label class="tf-option-label" for="option_{{ question.id }}_true">
                                                <div class="tf-option-content">
                                                    <div class="tf-icon">‚úì</div>
                                                    <div class="tf-text">True</div>
                                                    <div class="tf-description">This definition is correct</div>
                                                </div>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="tf-option-card false-option">
                                            <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                                   id="option_{{ question.id }}_false" value="false"
                                                   data-question="{{ question.id }}">
                                            <label class="tf-option-label" for="option_{{ question.id }}_false">
                                                <div class="tf-option-content">
                                                    <div class="tf-icon">‚úó</div>
                                                    <div class="tf-text">False</div>
                                                    <div class="tf-description">This definition is incorrect</div>
                                                </div>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% elif question.question_type == "matching" %}
                            <!-- Modern Matching Interface with Alpine.js + Sortable.js -->
                            <!-- React Matching Quiz -->
                            <div id="matching-quiz-{{ question.id }}"></div>

                            <script>
                            // Initialize React matching quiz when DOM is ready
                            document.addEventListener('DOMContentLoaded', function() {
                                if (window.mountMatchingQuiz) {
                                    const assignments = {};
                                    window.mountMatchingQuiz('matching-quiz-{{ question.id }}', {
                                        questionId: {{ question.id }},
                                        terms: {{ question.terms_json|safe }},
                                        definitions: {{ question.definitions_json|safe }},
                                        correctMatches: {{ question.correct_matches_json|safe }},
                                        onAssignmentChange: function(newAssignments) {
                                            // Store assignments globally for Next button logic
                                            window.matchingAssignments = window.matchingAssignments || {};
                                            window.matchingAssignments[{{ question.id }}] = newAssignments;

                                            console.log('Stored global assignments for question {{ question.id }}:', newAssignments);

                                            // Check if all terms are assigned
                                            const terms = {{ question.terms_json|safe }};
                                            const allAssigned = terms.every((_, index) =>
                                                newAssignments.hasOwnProperty(index) && newAssignments[index] !== undefined
                                            );

                                            console.log('Assignment check:', JSON.stringify(newAssignments), 'Terms length:', terms.length, 'All assigned:', allAssigned);

                                            // Enable/disable Next button and update help text
                                            const nextBtn = document.getElementById('next-btn-{{ question.id }}');
                                            const navHelp = document.querySelector('.navigation-help small');

                                            if (nextBtn) {
                                                nextBtn.disabled = !allAssigned;
                                                console.log('Next button disabled:', !allAssigned);

                                                // Add backup click handler
                                                if (allAssigned && !nextBtn._backupHandlerAdded) {
                                                    // Remove the disabled attribute completely
                                                    nextBtn.removeAttribute('disabled');
                                                    nextBtn.style.pointerEvents = 'auto';
                                                    nextBtn.style.opacity = '1';

                                                    nextBtn.addEventListener('click', function(e) {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        console.log('EventListener click handler executing');
                                                        try {
                                                            console.log('Checking function availability:', {
                                                                nextQuestion: typeof nextQuestion,
                                                                windowNextQuestion: typeof window.nextQuestion,
                                                                directNextQuestion: typeof window.directNextQuestion
                                                            });

                                                            if (typeof nextQuestion === 'function') {
                                                                console.log('‚úÖ Using direct nextQuestion');
                                                                nextQuestion();
                                                            } else if (typeof window.nextQuestion === 'function') {
                                                                console.log('‚úÖ Using window.nextQuestion');
                                                                window.nextQuestion();
                                                            } else if (typeof window.directNextQuestion === 'function') {
                                                                console.log('‚úÖ Using window.directNextQuestion');
                                                                window.directNextQuestion();
                                                            } else {
                                                                console.log('‚ùå No function available, trying after delay...');
                                                                setTimeout(() => {
                                                                    if (typeof nextQuestion === 'function') {
                                                                        nextQuestion();
                                                                    } else if (typeof window.nextQuestion === 'function') {
                                                                        window.nextQuestion();
                                                                    } else if (typeof window.directNextQuestion === 'function') {
                                                                        window.directNextQuestion();
                                                                    } else {
                                                                        console.error('‚ùå Still no function available after delay');
                                                                    }
                                                                }, 100);
                                                            }
                                                        } catch (error) {
                                                            console.error('‚ùå Error in event listener:', error);
                                                        }
                                                        return false;
                                                    });
                                                    nextBtn._backupHandlerAdded = true;

                                                    // Use inline function with comprehensive function checks
                                                    nextBtn.setAttribute('onclick', `
                                                        try {
                                                            console.log('Inline click handler executing');
                                                            console.log('Function check:', {
                                                                nextQuestion: typeof nextQuestion,
                                                                windowNextQuestion: typeof window.nextQuestion,
                                                                directNextQuestion: typeof window.directNextQuestion
                                                            });

                                                            if (typeof nextQuestion === 'function') {
                                                                console.log('‚úÖ Using direct nextQuestion from inline');
                                                                nextQuestion();
                                                            } else if (typeof window.nextQuestion === 'function') {
                                                                console.log('‚úÖ Using window.nextQuestion from inline');
                                                                window.nextQuestion();
                                                            } else if (typeof window.directNextQuestion === 'function') {
                                                                console.log('‚úÖ Using window.directNextQuestion from inline');
                                                                window.directNextQuestion();
                                                            } else {
                                                                console.log('‚ùå No function available from inline, trying delay...');
                                                                setTimeout(() => {
                                                                    if (typeof window.nextQuestion === 'function') {
                                                                        window.nextQuestion();
                                                                    } else if (typeof window.directNextQuestion === 'function') {
                                                                        window.directNextQuestion();
                                                                    } else {
                                                                        console.error('‚ùå Still no function from inline after delay');
                                                                    }
                                                                }, 100);
                                                            }
                                                        } catch (e) {
                                                            console.error('‚ùå Error in inline handler:', e);
                                                        }
                                                        return false;
                                                    `);
                                                }
                                            }

                                            if (navHelp) {
                                                if (allAssigned) {
                                                    navHelp.textContent = 'All terms matched! Click Next to continue';
                                                    navHelp.className = 'text-success';
                                                } else {
                                                    navHelp.textContent = 'Drag definitions to terms to continue';
                                                    navHelp.className = 'text-muted';
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                            </script>
                            {% else %}
                            <!-- Enhanced Multiple Choice Options -->
                            <div class="options-container">
                                {% for option in question.options %}
                                <div class="option-card mb-3">
                                    <input class="form-check-input d-none" type="radio" name="answer_{{ question.id }}"
                                           id="option_{{ question.id }}_{{ loop.index0 }}" value="{{ loop.index0 }}"
                                           data-question="{{ question.id }}"
                                           data-word-id="{% if question.option_word_ids %}{{ question.option_word_ids[loop.index0] }}{% endif %}">
                                    <label class="option-label" for="option_{{ question.id }}_{{ loop.index0 }}">
                                        <div class="option-content">
                                            <div class="option-letter">{{ ['A', 'B', 'C', 'D'][loop.index0] }}</div>
                                            <div class="option-text">
                                                {% if '; ' in option %}
                                                    {% set option_parts = option.split('; ') %}
                                                    <div class="option-main">{{ option_parts[0] }}</div>
                                                    {% if option_parts|length > 1 %}
                                                    <div class="option-details">
                                                        {% for detail in option_parts[1:] %}
                                                        <span class="detail-item">{{ detail }}</span>{% if not loop.last %}; {% endif %}
                                                        {% endfor %}
                                                    </div>
                                                    {% endif %}
                                                {% else %}
                                                    <div class="option-main">{{ option }}</div>
                                                {% endif %}
                                            </div>
                                            <div class="option-selector">
                                                <div class="radio-circle"></div>
                                            </div>
                                        </div>
                                    </label>
                                </div>
                                {% endfor %}
                            </div>
                            {% endif %}
                        </div>
                        
                        <!-- Enhanced Answer feedback (hidden initially) -->
                        <div class="answer-feedback mt-5" style="display: none;">
                            <div class="alert" role="alert">
                                <div class="feedback-card border-0 shadow-sm">
                                    <div class="feedback-header">
                                        <div class="feedback-icon"></div>
                                        <div class="feedback-content">
                                            <h5 class="feedback-result mb-1"></h5>
                                            <p class="feedback-explanation mb-0">{{ question.explanation }}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Navigation -->
                        <div class="quiz-navigation mt-5">
                            <div class="d-flex justify-content-between align-items-center">
                                <button class="btn btn-outline-secondary btn-lg px-4" id="prev-btn" onclick="previousQuestion()"
                                        {% if question.id == 1 %}style="visibility: hidden;"{% endif %}>
                                    <i class="fas fa-chevron-left me-2"></i> Previous
                                </button>
                                <div class="navigation-help text-center">
                                    <small class="text-muted">Select an answer to continue</small>
                                </div>
                                <button class="btn btn-primary btn-lg px-4" id="next-btn-{{ question.id }}" onclick="window.nextQuestion(); return false;" disabled>
                                    {% if question.id == questions|length %}
                                        <i class="fas fa-flag-checkered me-2"></i> Finish Quiz
                                    {% else %}
                                        Next <i class="fas fa-chevron-right ms-2"></i>
                                    {% endif %}
                                </button>
                            </div>
                        </div>
                        
                        <!-- Hidden data -->
                        <input type="hidden" class="correct-answer" value="{{ question.correct_answer }}">
                        <input type="hidden" class="word-id" value="{{ question.word_id }}">
                    </div>
                </div>
                {% endfor %}
            </div>
            
            <!-- Quiz Results (hidden initially) -->
            <div id="quiz-results" class="card" style="display: none;">
                <div class="card-body text-center">
                    <h3>üéâ Quiz Complete!</h3>
                    <div class="row mt-4">
                        <div class="col-md-4">
                            <div class="card border-success">
                                <div class="card-body">
                                    <h4 class="text-success" id="correct-count">0</h4>
                                    <p class="mb-0">Correct</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card border-danger">
                                <div class="card-body">
                                    <h4 class="text-danger" id="incorrect-count">0</h4>
                                    <p class="mb-0">Incorrect</p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card border-info">
                                <div class="card-body">
                                    <h4 class="text-info" id="accuracy">0%</h4>
                                    <p class="mb-0">Accuracy</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Comprehensive Review Section -->
                    <div id="comprehensive-review" class="mt-5">
                        <div class="card border-info">
                            <div class="card-header bg-info text-white text-start">
                                <h5 class="mb-0">üìù Complete Review - All Terms & Definitions</h5>
                                <small>Review all vocabulary from this quiz, including individual terms from matching questions</small>
                            </div>
                            <div class="card-body" id="review-content">
                                <!-- Review content will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <div class="mt-4">
                        <a href="/quiz" class="btn btn-primary me-2">Take Another Quiz</a>
                        <a href="/" class="btn btn-outline-secondary">Back to Home</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
console.log('üîÑ Script execution started');

let currentQuestionIndex = 0; // Index in the questions array (0-based)
let totalQuestions = {{ questions|length }};
let userAnswers = {};
let correctAnswers = 0;

// Get the actual question IDs in order
const questionIds = [
    {% for question in questions %}
    {{ question.id }}{% if not loop.last %},{% endif %}
    {% endfor %}
];

console.log('‚úÖ Variables defined:', {currentQuestionIndex, totalQuestions, questionIds});

// Define nextQuestion wrapper immediately to ensure global availability
function safeNextQuestion() {
    console.log('üöÄ safeNextQuestion called');
    if (typeof nextQuestion === 'function') {
        return nextQuestion();
    } else {
        console.error('nextQuestion function not available yet');
        // Try again after a short delay
        setTimeout(() => {
            if (typeof nextQuestion === 'function') {
                nextQuestion();
            }
        }, 100);
    }
}
window.safeNextQuestion = safeNextQuestion;

// Quiz data
console.log('üîÑ About to define quiz data');

try {
    var quizData = {
        {% for question in questions %}
    {{ question.id }}: {
        correctAnswer: {% if question.question_type == "matching" %}null{% elif question.correct_answer is sameas true %}true{% elif question.correct_answer is sameas false %}false{% elif question.correct_answer is not none %}{{ question.correct_answer }}{% else %}null{% endif %},
        {% if question.question_type == "matching" %}
        correctMatches: {{ question.correct_matches|tojson }},
        terms: {{ question.terms|tojson }},
        definitions: {{ question.definitions|tojson }},
        {% elif question.question_type == "multiple_choice" %}
        options: {{ question.options|tojson }},
        {% endif %}
        wordId: {{ question.word_id }},
        questionType: "{{ question.question_type }}",
        explanation: "{{ question.explanation|replace('"', '\\"') }}"
    }{% if not loop.last %},{% endif %}
    {% endfor %}
    };
    console.log('‚úÖ Quiz data successfully defined:', Object.keys(quizData));
} catch (error) {
    console.error('‚ùå Error defining quiz data:', error);
    // Create empty fallback
    var quizData = {};
}

console.log('‚úÖ About to define sessionId');
const sessionId = "{{ session_id }}";
console.log('‚úÖ SessionId defined:', sessionId);

function updateProgress() {
    const currentQuestionNumber = currentQuestionIndex + 1;
    const progress = (currentQuestionIndex / totalQuestions) * 100;
    document.getElementById('progress-bar').style.width = progress + '%';
    document.getElementById('current-question').textContent = currentQuestionNumber;

    // Update percentage display
    const percentageElement = document.getElementById('progress-percentage');
    if (percentageElement) {
        percentageElement.textContent = Math.round(progress) + '%';
    }

    // Update progress steps
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((step, index) => {
        const stepNumber = index + 1;
        step.classList.remove('completed', 'current');

        if (stepNumber < currentQuestionNumber) {
            step.classList.add('completed');
        } else if (stepNumber === currentQuestionNumber) {
            step.classList.add('current');
        }
    });
}

function showQuestion(questionId) {
    // Hide all questions
    document.querySelectorAll('.question-card').forEach(card => {
        card.style.display = 'none';
    });

    // Show current question
    const currentCard = document.querySelector(`[data-question="${questionId}"]`);
    if (currentCard) {
        currentCard.style.display = 'block';

        // Initialize matching functionality ONLY for this specific question if it's a matching question
        const isMatchingQuestion = currentCard.querySelector('.matching-container');
        if (isMatchingQuestion) {
            console.log('Showing matching question', questionId, 'initializing drag and drop for this question only');
            // Wait a brief moment for the DOM to be ready
            setTimeout(() => {
                // Find the Alpine.js component for this question and call initSortable
                const matchingContainer = isMatchingQuestion;
                if (matchingContainer && matchingContainer._x_dataStack && matchingContainer._x_dataStack.length > 0 && matchingContainer._x_dataStack[0]) {
                    console.log('Calling initSortable on visible question component');
                    matchingContainer._x_dataStack[0].initSortable();
                } else {
                    console.log('Alpine.js data stack not ready for matching question', questionId);
                }
            }, 200);  // Longer delay to ensure DOM is ready
        }
    }
    
    // Update navigation buttons
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById(`next-btn-${questionId}`);

    if (prevBtn) {
        if (currentQuestionIndex === 0) {
            prevBtn.style.visibility = 'hidden';
        } else {
            prevBtn.style.visibility = 'visible';
        }
    }

    if (nextBtn) {
        if (currentQuestionIndex === totalQuestions - 1) {
            nextBtn.textContent = 'Finish Quiz';
        } else {
            nextBtn.textContent = 'Next ‚Üí';
        }
    }

    // Check if question is already answered - but skip for matching questions
    const currentQuestionData = quizData && quizData[questionId];
    if (currentQuestionData && currentQuestionData.questionType === 'matching') {
        // For matching questions, the React component handles button state
        console.log('Matching question detected, skipping radio button check');
        // Initial state - will be updated by React component
        if (nextBtn) nextBtn.disabled = true;

        // Set initial help text for matching questions
        const navHelp = document.querySelector('.navigation-help small');
        if (navHelp) {
            navHelp.textContent = 'Drag definitions to terms to continue';
            navHelp.className = 'text-muted';
        }
    } else {
        // For non-matching questions, check if option is selected
        const selectedOption = document.querySelector(`input[name="answer_${questionId}"]:checked`);
        nextBtn.disabled = !selectedOption;
    }
}

console.log('‚úÖ About to define nextQuestion function');

function nextQuestion() {
    console.log('‚úÖ nextQuestion function executing');
    const currentQuestionId = questionIds[currentQuestionIndex];
    console.log('Current question ID:', currentQuestionId, 'Index:', currentQuestionIndex);
    console.log('QuizData available:', typeof quizData, 'Keys:', quizData ? Object.keys(quizData) : 'undefined');

    if (!quizData) {
        console.error('‚ùå quizData is not available');
        return;
    }

    const currentQuestionData = quizData[currentQuestionId];
    if (!currentQuestionData) {
        console.error('‚ùå No quiz data found for question', currentQuestionId);
        console.log('Available question IDs in quizData:', Object.keys(quizData));
        return;
    }
    const questionType = currentQuestionData.questionType;
    
    let userAnswer, correctAnswer, isCorrect;
    
    if (questionType === "matching") {
        // Handle matching questions - get matches from React component global state
        const userMatches = window.matchingAssignments && window.matchingAssignments[currentQuestionId]
            ? window.matchingAssignments[currentQuestionId]
            : {};

        // Check if all terms have matches
        const questionData = currentQuestionData;
        const expectedTermCount = questionData.terms ? questionData.terms.length : 0;
        const actualMatchCount = Object.keys(userMatches).length;

        if (actualMatchCount !== expectedTermCount) {
            console.error('Not all matches completed for question', currentQuestionId);
            return;
        }
        
        // Check correctness per term against quiz data
        // Reuse the questionData variable already declared above
        const correctMatches = questionData.correctMatches;
        let correctTermCount = 0;
        let totalTermCount = 0;
        const termResults = {};

        for (let termIdx in userMatches) {
            totalTermCount++;
            const isTermCorrect = userMatches[termIdx] === correctMatches[termIdx];
            if (isTermCorrect) {
                correctTermCount++;
            }
            termResults[termIdx] = {
                userAnswer: userMatches[termIdx],
                correctAnswer: correctMatches[termIdx],
                isCorrect: isTermCorrect
            };
        }

        // Add the correct term count to the overall score
        correctAnswers += correctTermCount;
        
        // Store user answer with per-term results
        userAnswers[currentQuestionId] = {
            matches: userMatches,
            questionType: 'matching',
            termResults: termResults,
            correctTermCount: correctTermCount,
            totalTermCount: totalTermCount,
            isCorrect: correctTermCount === totalTermCount // All terms correct
        };

        console.log('Stored matching answer:', userMatches, 'Per-term results:', termResults, `${correctTermCount}/${totalTermCount} correct`);

        // Show matching feedback with per-term results
        showMatchingFeedback(currentQuestionId, userMatches, correctMatches, termResults, correctTermCount, totalTermCount);
        
        // Continue with next question after delay (like other question types)
        setTimeout(() => {
            if (currentQuestionIndex < totalQuestions - 1) {
                currentQuestionIndex++;
                showQuestion(questionIds[currentQuestionIndex]);
                updateProgress();
            } else {
                showResults();
            }
        }, 2000);
        return;
    }
    
    // Handle multiple choice and true/false questions
    const selectedOption = document.querySelector(`input[name="answer_${currentQuestionId}"]:checked`);
    if (!selectedOption) return;
    
    if (questionType === "true_false") {
        userAnswer = selectedOption.value === "true";
        correctAnswer = currentQuestionData.correctAnswer;
        isCorrect = userAnswer === correctAnswer;
    } else {
        userAnswer = parseInt(selectedOption.value);
        correctAnswer = currentQuestionData.correctAnswer;
        // Ensure both are integers for comparison - handle any type inconsistencies
        correctAnswer = typeof correctAnswer === 'number' ? correctAnswer : parseInt(correctAnswer);
        isCorrect = userAnswer === correctAnswer;
    }
    
    // Get the chosen distractor word ID for mistake tracking
    const chosenDistractorId = selectedOption.getAttribute('data-word-id');
    
    // Store user answer
    userAnswers[currentQuestionId] = {
        selected: userAnswer,
        correct: correctAnswer,
        isCorrect: isCorrect,
        chosenDistractorId: chosenDistractorId
    };
    
    if (isCorrect) {
        correctAnswers++;
    }
    
    // Show feedback
    showFeedback(currentQuestionId, isCorrect);

    // Move to next question after delay
    setTimeout(() => {
        if (currentQuestionIndex < totalQuestions - 1) {
            currentQuestionIndex++;
            showQuestion(questionIds[currentQuestionIndex]);
            updateProgress();
        } else {
            showResults();
        }
    }, 2000);
}

// Make nextQuestion globally accessible for onclick handlers
window.nextQuestion = nextQuestion;
console.log('‚úÖ nextQuestion function defined and assigned to window.nextQuestion');

// Also create a direct reference for the inline handlers
window.directNextQuestion = nextQuestion;
console.log('‚úÖ directNextQuestion also assigned');

function previousQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        showQuestion(questionIds[currentQuestionIndex]);
        updateProgress();

        // For matching questions, button state is handled by React component
    }
}

function showFeedback(questionNum, isCorrect) {
    const feedbackDiv = document.querySelector(`[data-question="${questionNum}"] .answer-feedback`);
    const resultSpan = feedbackDiv.querySelector('.feedback-result');
    const alertDiv = feedbackDiv.querySelector('.feedback-card');

    if (isCorrect) {
        feedbackDiv.querySelector('.alert').className = 'alert alert-success';
        resultSpan.textContent = 'Correct!';
    } else {
        feedbackDiv.querySelector('.alert').className = 'alert alert-danger';
        resultSpan.textContent = 'Incorrect';
    }

    feedbackDiv.style.display = 'block';

    // Disable all options
    document.querySelectorAll(`input[name="answer_${questionNum}"]`).forEach(input => {
        input.disabled = true;
    });

    // Update navigation help text
    const navHelp = document.querySelector('.navigation-help small');
    if (navHelp) {
        navHelp.textContent = 'Review the feedback and continue';
    }
}

function showMatchingFeedback(questionId, userMatches, correctMatches, termResults, correctTermCount, totalTermCount) {
    console.log('Showing matching feedback for question', questionId);

    // Find the feedback container for this question
    const feedbackDiv = document.querySelector(`[data-question="${questionId}"] .answer-feedback`);
    if (!feedbackDiv) {
        console.warn('No feedback div found for matching question', questionId);
        return;
    }

    const resultSpan = feedbackDiv.querySelector('.feedback-result');
    const alertDiv = feedbackDiv.querySelector('.alert');

    // Determine overall correctness
    const allCorrect = correctTermCount === totalTermCount;

    if (allCorrect) {
        if (alertDiv) alertDiv.className = 'alert alert-success';
        if (resultSpan) resultSpan.textContent = `Perfect! All ${totalTermCount} matches correct!`;
    } else {
        if (alertDiv) alertDiv.className = 'alert alert-warning';
        if (resultSpan) resultSpan.textContent = `${correctTermCount} out of ${totalTermCount} matches correct`;
    }

    // Show detailed feedback for each term if there's a feedback details area
    const feedbackDetails = feedbackDiv.querySelector('.feedback-details');
    if (feedbackDetails && termResults) {
        let detailsHTML = '<ul class="list-unstyled mt-2 small">';
        for (let termIdx in termResults) {
            const result = termResults[termIdx];
            const icon = result.isCorrect ? '‚úÖ' : '‚ùå';
            detailsHTML += `<li>${icon} Term ${parseInt(termIdx) + 1}: ${result.isCorrect ? 'Correct' : 'Incorrect'}</li>`;
        }
        detailsHTML += '</ul>';
        feedbackDetails.innerHTML = detailsHTML;
    }

    // Show the feedback
    feedbackDiv.style.display = 'block';

    // Disable the matching interface (make items non-draggable)
    const matchingContainer = document.querySelector(`[data-question="${questionId}"] .matching-container`);
    if (matchingContainer) {
        matchingContainer.style.pointerEvents = 'none';
        matchingContainer.style.opacity = '0.7';
    }

    // Update navigation help text
    const navHelp = document.querySelector('.navigation-help small');
    if (navHelp) {
        navHelp.textContent = 'Review the matching results and continue';
    }
}

function showResults() {
    // Hide quiz container
    document.getElementById('quiz-container').style.display = 'none';

    // Show results
    const resultsDiv = document.getElementById('quiz-results');
    resultsDiv.style.display = 'block';

    // Calculate actual total questions including individual terms in matching questions
    let actualTotalQuestions = 0;
    for (let i = 1; i <= totalQuestions; i++) {
        if (userAnswers[i] && userAnswers[i].questionType === 'matching') {
            actualTotalQuestions += userAnswers[i].totalTermCount;
        } else {
            actualTotalQuestions += 1; // Regular question counts as 1
        }
    }

    // Update result numbers
    const incorrectCount = actualTotalQuestions - correctAnswers;
    const accuracy = Math.round((correctAnswers / actualTotalQuestions) * 100);
    
    document.getElementById('correct-count').textContent = correctAnswers;
    document.getElementById('incorrect-count').textContent = incorrectCount;
    document.getElementById('accuracy').textContent = accuracy + '%';
    
    // Hide progress bar
    document.querySelector('.card.mb-4').style.display = 'none';

    // Populate comprehensive review section
    populateComprehensiveReview();

    // AUTO-SUBMIT results in background - no manual action required
    console.log('üîÑ Auto-saving quiz results...');
    autoSaveQuizResults();

    // Show navigation buttons (no manual save needed)
    addNavigationButtons();
}

function populateComprehensiveReview(userAnswersData = null, quizDataParam = null) {
    const reviewContent = document.getElementById('review-content');
    if (!reviewContent) {
        console.error('review-content element not found!');
        return;
    }

    console.log('Starting populateComprehensiveReview');

    // Use provided data or try to get from various sources
    let actualUserAnswers = userAnswersData || window.userAnswers || userAnswers || {};
    let actualQuizData = quizDataParam || window.quizData || quizData || {};

    console.log('Raw userAnswers keys:', Object.keys(actualUserAnswers));
    console.log('Raw userAnswers:', actualUserAnswers);
    console.log('Raw quizData keys:', Object.keys(actualQuizData));

    // Check if the data structure is different than expected
    for (let key in actualUserAnswers) {
        console.log(`userAnswer[${key}]:`, actualUserAnswers[key]);
    }

    // Check if we have real quiz data
    if (!actualUserAnswers || Object.keys(actualUserAnswers).length === 0) {
        console.error('No quiz data found! Cannot populate comprehensive review.');
        reviewContent.innerHTML = '<div class="alert alert-warning"><strong>No quiz data available for review.</strong> Please try taking the quiz again.</div>';
        return;
    }

    let reviewHTML = '<div class="row">';
    let termCount = 0;

    // Collect all terms for review
    for (let questionId in actualUserAnswers) {
        console.log(`Processing question ${questionId}`);
        const answer = actualUserAnswers[questionId];
        const questionData = actualQuizData[questionId];

        console.log('Answer:', answer);
        console.log('Question data:', questionData);

        if (!answer || !questionData) {
            console.warn(`Missing data for question ${questionId}`);
            continue;
        }

        // Handle different data structures based on what was actually stored
        console.log(`Question ${questionId} condition check:`, answer.questionType === 'matching', !!(answer.termResults && questionData.terms));
        if (answer.questionType === 'matching' || (answer.termResults && questionData.terms)) {
            console.log(`Processing question ${questionId} as MATCHING`);
            // Add each term from matching questions - termResults can be array or object
            const termResults = answer.termResults;
            if (Array.isArray(termResults)) {
                // Handle array format
                for (let i = 0; i < termResults.length; i++) {
                    const termResult = termResults[i];

                    // For matching questions, terms are stored as strings in questionData.terms array
                    const termName = questionData.terms[i];
                    // Get the correct definition for this term
                    const correctDefIndex = questionData.correctMatches[i];
                    const correctDefinition = questionData.definitions[correctDefIndex];

                    reviewHTML += `
                        <div class="col-md-6 mb-3">
                            <div class="card h-100 ${termResult.isCorrect ? 'border-success' : 'border-danger'}">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <h6 class="card-title mb-1">
                                            <strong>${termName}</strong>
                                        </h6>
                                        <span class="badge ${termResult.isCorrect ? 'bg-success' : 'bg-danger'}">
                                            ${termResult.isCorrect ? '‚úì' : '‚úó'}
                                        </span>
                                    </div>
                                    <p class="card-text mb-2"><strong>Definition:</strong> ${correctDefinition}</p>

                                    ${termResult.isCorrect ?
                                        `<div class="alert alert-success p-2 mb-2">
                                            <small><strong>‚úì Correct Match:</strong> ${correctDefinition}</small>
                                        </div>` :
                                        `<div class="alert alert-danger p-2 mb-2">
                                            <small class="d-block"><strong>‚úó You matched with:</strong> ${questionData.definitions[termResult.userAnswer]}</small>
                                            <small class="d-block"><strong>‚úì Should be:</strong> ${correctDefinition}</small>
                                        </div>`
                                    }

                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">Matching</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    termCount++;
                    console.log(`Added matching term: ${termName}`);
                }
            } else if (typeof termResults === 'object' && termResults !== null) {
                // Handle object format (e.g., {0: {...}, 1: {...}, 2: {...}})
                for (let termIdx in termResults) {
                    const termResult = termResults[termIdx];
                    const termIndex = parseInt(termIdx);

                    // For matching questions, terms are stored as strings in questionData.terms array
                    const termName = questionData.terms[termIndex];
                    // Get the correct definition for this term
                    const correctDefIndex = questionData.correctMatches[termIndex];
                    const correctDefinition = questionData.definitions[correctDefIndex];

                    reviewHTML += `
                        <div class="col-md-6 mb-3">
                            <div class="card h-100 ${termResult.isCorrect ? 'border-success' : 'border-danger'}">
                                <div class="card-body">
                                    <div class="d-flex justify-content-between align-items-start mb-2">
                                        <h6 class="card-title mb-1">
                                            <strong>${termName}</strong>
                                        </h6>
                                        <span class="badge ${termResult.isCorrect ? 'bg-success' : 'bg-danger'}">
                                            ${termResult.isCorrect ? '‚úì' : '‚úó'}
                                        </span>
                                    </div>
                                    <p class="card-text mb-2"><strong>Definition:</strong> ${correctDefinition}</p>

                                    ${termResult.isCorrect ?
                                        `<div class="alert alert-success p-2 mb-2">
                                            <small><strong>‚úì Correct Match:</strong> ${correctDefinition}</small>
                                        </div>` :
                                        `<div class="alert alert-danger p-2 mb-2">
                                            <small class="d-block"><strong>‚úó You matched with:</strong> ${questionData.definitions[termResult.userAnswer]}</small>
                                            <small class="d-block"><strong>‚úì Should be:</strong> ${correctDefinition}</small>
                                        </div>`
                                    }

                                    <div class="d-flex justify-content-between align-items-center">
                                        <small class="text-muted">Matching</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    termCount++;
                    console.log(`Added matching term: ${termName}`);
                }
            } else {
                console.warn('termResults is not an array or object:', termResults);
            }
        } else {
            // Handle different property names for non-matching questions
            console.log(`ENTERING NON-MATCHING BRANCH for question ${questionId}, questionType: ${questionData.questionType}`);
            const isCorrect = answer.isCorrect !== undefined ? answer.isCorrect : false;
            let userAnswerText = 'Not answered';
            let userSelectedIndex = answer.selected;

            // Extract term from question text for multiple choice/true-false
            let termName = 'Unknown term';
            let termDefinition = 'No definition available';
            let correctAnswerText = 'Unknown';

            // Try to extract from explanation - multiple patterns
            if (questionData.explanation) {
                // Pattern 1: "TRUE: 'term' does mean 'definition'"
                const trueMatch = questionData.explanation.match(/TRUE:\s*['"]([^'"]+)['"] does mean ['"]([^'"]+)['"]/);
                if (trueMatch) {
                    termName = trueMatch[1];
                    termDefinition = trueMatch[2];
                }

                // Pattern 2: "FALSE: 'term' actually means 'definition'"
                const falseMatch = questionData.explanation.match(/FALSE:\s*['"]([^'"]+)['"] actually means ['"]([^'"]+)['"]/);
                if (falseMatch) {
                    termName = falseMatch[1];
                    termDefinition = falseMatch[2];
                }

                // Pattern 3: "'term' means: definition" (original)
                const explMatch = questionData.explanation.match(/['"]([^'"]+)['"] means:\s*(.+)/);
                if (explMatch) {
                    termName = explMatch[1];
                    termDefinition = explMatch[2];
                }
            }

            // Debug what's actually in questionData
            console.log(`Question ${questionId} - questionData.explanation:`, questionData.explanation);

            // Extract term from explanation text since questionData.question is undefined
            if (questionData.explanation) {
                // First decode HTML entities for easier regex matching
                const decodedExplanation = questionData.explanation
                    .replace(/&#39;/g, "'")
                    .replace(/&quot;/g, '"')
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>');

                console.log(`Decoded explanation: ${decodedExplanation}`);

                // For TF questions: "FALSE: 'taw' actually means..." or "TRUE: 'word' means..."
                const tfMatch = decodedExplanation.match(/(?:TRUE|FALSE):\s*'([^']+)'/);
                if (tfMatch) {
                    termName = tfMatch[1];
                    console.log(`TF term extracted from explanation: ${termName}`);
                }

                // For MC questions: "'kinderspiel' means: A dramatic piece..."
                const mcMatch = decodedExplanation.match(/'([^']+)'\s+means:/);
                if (mcMatch) {
                    termName = mcMatch[1];
                    console.log(`MC term extracted from explanation: ${termName}`);
                }

                // For the comprehensive review, we should use the actual definition from the database
                // rather than trying to parse it from explanation text
                if (questionData.wordId && termName) {
                    // Fetch the actual definition from the database
                    fetch(`/api/words/${questionData.wordId}`)
                        .then(response => response.json())
                        .then(data => {
                            termDefinition = data.word.definition;
                            console.log(`Fetched definition for ${termName}: ${termDefinition}`);
                            // Update the review display with the real definition
                            updateTermDefinitionInReview(questionId, termDefinition);
                        })
                        .catch(error => {
                            console.error(`Failed to fetch definition for ${termName}:`, error);
                            termDefinition = 'Definition unavailable';
                        });
                }
            } else {
                console.log(`Question ${questionId} - NO explanation available`);
            }

            // For multiple choice, try to get the answer text from various sources
            if (questionData.questionType === 'multiple_choice') {
                console.log(`Processing MC question ${questionId}, correctAnswer: ${questionData.correctAnswer}, userSelected: ${answer.selected}`);
                // If options array exists, use it
                if (questionData.options && questionData.correctAnswer !== undefined) {
                    correctAnswerText = questionData.options[questionData.correctAnswer];
                    if (answer.selected !== undefined && questionData.options) {
                        userAnswerText = questionData.options[answer.selected];
                    }
                    console.log(`Using options array: user="${userAnswerText}", correct="${correctAnswerText}"`);
                } else {
                    // Fallback: use simple text based on answer indices
                    correctAnswerText = `Answer choice ${questionData.correctAnswer}`;
                    if (answer.selected !== undefined) {
                        userAnswerText = `Answer choice ${answer.selected}`;
                    }
                    console.log(`Using fallback: user="${userAnswerText}", correct="${correctAnswerText}"`);
                }
            }

            // For true/false, correct answer is True/False
            if (questionData.questionType === 'true_false') {
                correctAnswerText = questionData.correctAnswer ? 'True' : 'False';
                userAnswerText = answer.selected ? 'True' : 'False';
                // termDefinition should already be set from explanation extraction above
            }

            // Add single term from other question types
            reviewHTML += `
                <div class="col-md-6 mb-3" data-question-id="${questionId}">
                    <div class="card h-100 ${isCorrect ? 'border-success' : 'border-danger'}">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <h6 class="card-title mb-1">
                                    <strong>${termName}</strong>
                                </h6>
                                <span class="badge ${isCorrect ? 'bg-success' : 'bg-danger'}">
                                    ${isCorrect ? '‚úì' : '‚úó'}
                                </span>
                            </div>
                            <p class="card-text mb-2"><strong>Definition:</strong> <span class="definition-text">${termDefinition}</span></p>

                            ${!isCorrect ?
                                `<div class="alert alert-danger p-2 mb-2">
                                    <small class="d-block"><strong>‚úó Your answer:</strong> ${userAnswerText}</small>
                                    <small class="d-block"><strong>‚úì Correct answer:</strong> ${correctAnswerText}</small>
                                </div>` : ''
                            }

                            <div class="d-flex justify-content-between align-items-center">
                                <small class="text-muted">${questionData.questionType || questionData.question_type || 'QUESTION'}</small>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            termCount++;
            console.log(`Adding non-matching question ${questionId}: ${questionData?.term || 'unknown'}`);
        }
    }

    reviewHTML += '</div>';

    console.log(`Generated review HTML for ${termCount} terms:`, reviewHTML);

    if (termCount === 0) {
        reviewHTML = '<div class="alert alert-info">No quiz data available for review. Please try taking another quiz.</div>';
        console.warn('No terms found for review - showing fallback message');
    }

    reviewContent.innerHTML = reviewHTML;
    console.log('Review content populated successfully');
}

function updateTermDefinitionInReview(questionId, definition) {
    // Find the term card for this question and update its definition
    const reviewContent = document.getElementById('review-content');
    if (reviewContent) {
        // Look for definition text to update - use a more specific selector
        const definitionElement = reviewContent.querySelector(`[data-question-id="${questionId}"] .definition-text`);
        if (definitionElement) {
            definitionElement.textContent = definition;
            console.log(`Updated definition display for question ${questionId}`);
        } else {
            console.log(`Could not find definition element for question ${questionId}`);
        }
    }
}

function addSubmitButton() {
    // Add a button to submit results to server (optional)
    const resultsSection = document.getElementById('quiz-results');
    if (!resultsSection) return;

    // Check if button already exists
    if (document.getElementById('submit-results-btn')) return;

    // Create submit button container
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'text-center mt-4 mb-4';
    buttonContainer.innerHTML = `
        <button id="submit-results-btn" class="btn btn-primary btn-lg me-3" onclick="submitQuizResults()">
            üíæ Save Results & Continue
        </button>
        <button class="btn btn-outline-secondary" onclick="location.href='/quiz'">
            üîÑ Take Another Quiz
        </button>
        <button class="btn btn-outline-info" onclick="location.href='/'">
            üè† Back to Home
        </button>
    `;

    resultsSection.appendChild(buttonContainer);
}

function handleMatchingChange(selectElement) {
    const questionNum = parseInt(selectElement.dataset.question);
    const termIndex = parseInt(selectElement.dataset.termIndex);
    const selectedDefIndex = selectElement.value;
    
    console.log('Matching change:', questionNum, 'term:', termIndex, 'def:', selectedDefIndex);
    
    // Get all select elements for this question
    const allSelects = document.querySelectorAll(`select[data-question="${questionNum}"]`);
    
    // Check if all matches have been made
    let allMatched = true;
    const userMatches = {};
    
    allSelects.forEach(select => {
        const tIndex = parseInt(select.dataset.termIndex);
        const defIndex = select.value;
        
        if (defIndex === '') {
            allMatched = false;
        } else {
            userMatches[tIndex] = parseInt(defIndex);
        }
    });
    
    // If all matches are made, check correctness and enable next button
    if (allMatched) {
        const questionData = quizData[questionNum];
        const correctMatches = questionData.correctMatches;
        
        // Check if user matches are correct
        let isCorrect = true;
        for (let termIdx in userMatches) {
            if (userMatches[termIdx] !== correctMatches[termIdx]) {
                isCorrect = false;
                break;
            }
        }
        
        // Store the user's answer
        userAnswers[questionNum] = {
            matches: userMatches,
            isCorrect: isCorrect,
            questionType: 'matching'
        };
        
        // Enable next button
        const nextBtn = document.getElementById(`next-btn-${questionNum}`);
        if (nextBtn) {
            nextBtn.disabled = false;
            console.log('Next button enabled for question', questionNum);
        }
        
        // Visual feedback for matches
        allSelects.forEach(select => {
            const tIndex = parseInt(select.dataset.termIndex);
            const userDefIndex = userMatches[tIndex];
            const correctDefIndex = correctMatches[tIndex];
            
            // Add visual feedback classes
            const termCard = select.closest('.term-item');
            if (userDefIndex === correctDefIndex) {
                termCard.classList.add('border-success');
                termCard.classList.remove('border-danger');
                select.classList.add('text-success');
            } else {
                termCard.classList.add('border-danger');
                termCard.classList.remove('border-success');
                select.classList.add('text-danger');
            }
        });
    } else {
        // Disable next button if not all matches are made
        const nextBtn = document.getElementById(`next-btn-${questionNum}`);
        if (nextBtn) {
            nextBtn.disabled = true;
        }
    }
}

function submitQuizResults() {
    // Calculate actual total questions including individual terms in matching questions
    let actualTotalQuestions = 0;
    for (let i = 1; i <= totalQuestions; i++) {
        if (userAnswers[i] && userAnswers[i].questionType === 'matching') {
            actualTotalQuestions += userAnswers[i].totalTermCount;
        } else {
            actualTotalQuestions += 1; // Regular question counts as 1
        }
    }

    // Prepare results data
    const questionResults = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Create one result record per term in matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                questionResults.push({
                    word_id: questionData.words[termIdx].id, // Get specific word ID for this term
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    response_time_ms: answer.responseTime || 3000,
                    chosen_distractor_id: null, // Matching doesn't use distractor IDs
                    user_answer: termResult.userAnswer,
                    correct_answer: termResult.correctAnswer
                });
            }
        } else {
            // Handle regular questions as before
            questionResults.push({
                word_id: questionData.wordId,
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                response_time_ms: answer.responseTime || 3000,
                chosen_distractor_id: answer.isCorrect ? null : (answer.chosenDistractorId ? parseInt(answer.chosenDistractorId) : null)
            });
        }
    }
    
    // Collect all terms for comprehensive review
    const allTermsReview = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Add each term from matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                const termData = questionData.words[termIdx];
                allTermsReview.push({
                    term: termData.term,
                    definition: termData.definition,
                    part_of_speech: termData.part_of_speech || 'NOUN',
                    domain: termData.domain || '',
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    user_answer: questionData.definitions[termResult.userAnswer] || '',
                    correct_answer: questionData.definitions[termResult.correctAnswer] || ''
                });
            }
        } else {
            // Add single term from other question types
            allTermsReview.push({
                term: questionData.term,
                definition: questionData.definition,
                part_of_speech: questionData.part_of_speech || 'NOUN',
                domain: questionData.domain || '',
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                user_answer: answer.selectedOption || '',
                correct_answer: questionData.correctAnswer || ''
            });
        }
    }

    const resultsData = {
        correctCount: correctAnswers,
        totalQuestions: actualTotalQuestions,
        accuracy: Math.round((correctAnswers / actualTotalQuestions) * 100),
        difficulty: "{{ difficulty }}",
        quizType: "{{ quiz_type }}",
        score: Math.round((correctAnswers / actualTotalQuestions) * 100),
        questions: questionResults,
        reviewData: allTermsReview
    };
    
    // Submit via form
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = '/quiz/submit';
    form.style.display = 'none';
    
    const sessionInput = document.createElement('input');
    sessionInput.name = 'session_id';
    sessionInput.value = sessionId;
    form.appendChild(sessionInput);
    
    const resultsInput = document.createElement('input');
    resultsInput.name = 'results';
    resultsInput.value = JSON.stringify(resultsData);
    form.appendChild(resultsInput);
    
    document.body.appendChild(form);
    form.submit();
}

function autoSaveQuizResults() {
    // Calculate actual total questions including individual terms in matching questions
    let actualTotalQuestions = 0;
    for (let i = 1; i <= totalQuestions; i++) {
        if (userAnswers[i] && userAnswers[i].questionType === 'matching') {
            actualTotalQuestions += userAnswers[i].totalTermCount;
        } else {
            actualTotalQuestions += 1; // Regular question counts as 1
        }
    }

    // Prepare results data (same as submitQuizResults but for AJAX)
    const questionResults = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Create one result record per term in matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                questionResults.push({
                    word_id: questionData.words[termIdx].id, // Get specific word ID for this term
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    response_time_ms: answer.responseTime || 3000,
                    chosen_distractor_id: null, // Matching doesn't use distractor IDs
                    user_answer: termResult.userAnswer,
                    correct_answer: termResult.correctAnswer
                });
            }
        } else {
            // Handle regular questions as before
            questionResults.push({
                word_id: questionData.wordId,
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                response_time_ms: answer.responseTime || 3000,
                chosen_distractor_id: answer.isCorrect ? null : (answer.chosenDistractorId ? parseInt(answer.chosenDistractorId) : null)
            });
        }
    }

    // Collect all terms for comprehensive review
    const allTermsReview = [];
    for (let questionId in userAnswers) {
        const answer = userAnswers[questionId];
        const questionData = quizData[questionId];

        if (answer.questionType === 'matching') {
            // Add each term from matching questions
            for (let termIdx in answer.termResults) {
                const termResult = answer.termResults[termIdx];
                const termData = questionData.words[termIdx];
                allTermsReview.push({
                    term: termData.term,
                    definition: termData.definition,
                    part_of_speech: termData.part_of_speech || 'NOUN',
                    domain: termData.domain || '',
                    question_type: 'matching',
                    is_correct: termResult.isCorrect,
                    user_answer: questionData.definitions[termResult.userAnswer] || '',
                    correct_answer: questionData.definitions[termResult.correctAnswer] || ''
                });
            }
        } else {
            // Add single term from other question types
            allTermsReview.push({
                term: questionData.term,
                definition: questionData.definition,
                part_of_speech: questionData.part_of_speech || 'NOUN',
                domain: questionData.domain || '',
                question_type: questionData.questionType,
                is_correct: answer.isCorrect,
                user_answer: answer.selectedOption || '',
                correct_answer: questionData.correctAnswer || ''
            });
        }
    }

    const resultsData = {
        correctCount: correctAnswers,
        totalQuestions: actualTotalQuestions,
        accuracy: Math.round((correctAnswers / actualTotalQuestions) * 100),
        difficulty: "{{ difficulty }}",
        quizType: "{{ quiz_type }}",
        score: Math.round((correctAnswers / actualTotalQuestions) * 100),
        questions: questionResults,
        reviewData: allTermsReview
    };

    // Submit via AJAX instead of form redirect
    fetch('/quiz/submit', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `session_id=${encodeURIComponent(sessionId)}&results=${encodeURIComponent(JSON.stringify(resultsData))}`
    })
    .then(response => {
        if (response.ok) {
            console.log('‚úÖ Quiz results saved successfully');
            // Show success indicator
            showSaveSuccessIndicator();
        } else {
            console.error('‚ùå Failed to save quiz results');
            showSaveErrorIndicator();
        }
    })
    .catch(error => {
        console.error('‚ùå Error saving quiz results:', error);
        showSaveErrorIndicator();
    });
}

function addNavigationButtons() {
    // Add navigation buttons (no manual save needed)
    const resultsSection = document.getElementById('quiz-results');
    if (!resultsSection) return;

    // Check if buttons already exist
    if (document.getElementById('navigation-buttons')) return;

    // Create navigation button container
    const buttonContainer = document.createElement('div');
    buttonContainer.id = 'navigation-buttons';
    buttonContainer.className = 'text-center mt-4 mb-4';
    buttonContainer.innerHTML = `
        <div class="alert alert-success d-none" id="save-success">
            ‚úÖ Results saved successfully!
        </div>
        <div class="alert alert-danger d-none" id="save-error">
            ‚ùå Failed to save results. Please try refreshing the page.
        </div>
        <button class="btn btn-primary btn-lg me-3" onclick="location.href='/quiz'">
            üîÑ Take Another Quiz
        </button>
        <button class="btn btn-outline-info" onclick="location.href='/'">
            üè† Back to Home
        </button>
    `;

    resultsSection.appendChild(buttonContainer);
}

function showSaveSuccessIndicator() {
    const successDiv = document.getElementById('save-success');
    if (successDiv) {
        successDiv.classList.remove('d-none');
    }
}

function showSaveErrorIndicator() {
    const errorDiv = document.getElementById('save-error');
    if (errorDiv) {
        errorDiv.classList.remove('d-none');
    }
}

// Enable next button when option is selected
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio') {
        const questionId = parseInt(e.target.dataset.question);
        const currentQuestionId = questionIds[currentQuestionIndex];
        console.log('Radio change event:', questionId, 'current:', currentQuestionId);
        if (questionId === currentQuestionId) {
            const nextBtn = document.getElementById(`next-btn-${questionId}`);
            if (nextBtn) {
                nextBtn.disabled = false;
                console.log('Next button enabled for question', questionId);
            }
        }
    }
});

// Also add click event listener as backup
document.addEventListener('click', function(e) {
    if (e.target.type === 'radio') {
        const questionId = parseInt(e.target.dataset.question);
        const currentQuestionId = questionIds[currentQuestionIndex];
        if (questionId === currentQuestionId) {
            const nextBtn = document.getElementById(`next-btn-${questionId}`);
            if (nextBtn) {
                nextBtn.disabled = false;
            }
        }
    }
});

// Old complex drag-and-drop code has been removed - now using Alpine.js + Sortable.js

updateProgress();
</script>

<style>
/* ========================================
   ENHANCED QUIZ INTERFACE STYLES
   ======================================== */

/* Enhanced Quiz Progress */
.quiz-progress-card {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-left: 4px solid var(--color-primary) !important;
}

.quiz-progress-info h4 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.progress-percentage {
    font-size: 1.1rem;
    font-weight: 600;
}

.quiz-progress-steps {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #e2e8f0;
}

.progress-step {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
}

.step-circle {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #e2e8f0;
    color: #64748b;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.progress-step.completed .step-circle {
    background-color: var(--color-primary);
    color: white;
}

.progress-step.current .step-circle {
    background-color: var(--color-primary);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
}

/* Enhanced Question Cards */
.question-card {
    border-radius: 16px !important;
}

.question-header {
    border-bottom: 2px solid #f1f5f9;
    padding-bottom: 1.5rem;
}

.question-type-label {
    font-size: 1.1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.question-word-highlight {
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    padding: 1rem 1.5rem;
    border-radius: 12px;
    border-left: 4px solid var(--color-primary);
}

.featured-word {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-primary);
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    padding: 0 0.5rem;
}

.definition-block {
    margin-top: 1.5rem;
}

.definition-quote {
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 1.5rem;
    margin: 0;
    position: relative;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
}

.definition-quote::before {
    content: '\201C';
    font-size: 3rem;
    color: var(--color-primary);
    position: absolute;
    top: -0.5rem;
    left: 1rem;
    line-height: 1;
}

.definition-text {
    font-size: 1.1rem;
    line-height: 1.6;
    color: #374151;
    margin: 0;
    padding-left: 2rem;
}

/* Enhanced Multiple Choice Options */
.options-container {
    margin-top: 2rem;
}

.option-card {
    transition: all 0.2s ease;
}

.option-label {
    display: block;
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.option-label:hover {
    border-color: var(--color-primary);
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(37, 99, 235, 0.15);
}

.option-content {
    display: flex;
    align-items: flex-start;
    padding: 1.25rem;
    gap: 1rem;
}

.option-letter {
    width: 32px;
    height: 32px;
    background: var(--color-primary);
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 0.9rem;
    flex-shrink: 0;
}

.option-text {
    flex: 1;
    min-width: 0;
}

.option-main {
    font-size: 1rem;
    line-height: 1.5;
    color: #374151;
    font-weight: 500;
    margin-bottom: 0.5rem;
}

.option-details {
    font-size: 0.9rem;
    line-height: 1.4;
    color: #6b7280;
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
}

.detail-item {
    padding: 0.25rem 0.5rem;
    background: #f9fafb;
    border-radius: 6px;
    border: 1px solid #e5e7eb;
}

.option-selector {
    flex-shrink: 0;
    margin-top: 0.25rem;
}

.radio-circle {
    width: 20px;
    height: 20px;
    border: 2px solid #d1d5db;
    border-radius: 50%;
    transition: all 0.2s ease;
    position: relative;
}

.radio-circle::after {
    content: '';
    width: 8px;
    height: 8px;
    background: var(--color-primary);
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.2s ease;
}

/* Selected state */
input[type="radio"]:checked + .option-label {
    border-color: var(--color-primary);
    background: rgba(37, 99, 235, 0.02);
}

input[type="radio"]:checked + .option-label .option-letter {
    background: var(--color-primary);
    transform: scale(1.1);
}

input[type="radio"]:checked + .option-label .radio-circle {
    border-color: var(--color-primary);
}

input[type="radio"]:checked + .option-label .radio-circle::after {
    transform: translate(-50%, -50%) scale(1);
}

/* Enhanced True/False Options */
.true-false-container {
    margin-top: 2rem;
}

.tf-option-card {
    height: 100%;
    transition: all 0.2s ease;
}

.tf-option-label {
    display: block;
    height: 100%;
    background: #ffffff;
    border: 2px solid #f1f5f9;
    border-radius: 12px;
    padding: 0;
    margin: 0;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.tf-option-label:hover {
    transform: translateY(-3px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
}

.true-option .tf-option-label:hover {
    border-color: #10b981;
    box-shadow: 0 12px 30px rgba(16, 185, 129, 0.2);
}

.false-option .tf-option-label:hover {
    border-color: #ef4444;
    box-shadow: 0 12px 30px rgba(239, 68, 68, 0.2);
}

.tf-option-content {
    padding: 2rem 1.5rem;
    text-align: center;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.tf-icon {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #6b7280;
    transition: all 0.2s ease;
}

.true-option .tf-icon {
    color: #10b981;
}

.false-option .tf-icon {
    color: #ef4444;
}

.tf-text {
    font-size: 1.5rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 0.5rem;
}

.tf-description {
    font-size: 0.9rem;
    color: #6b7280;
    line-height: 1.4;
}

/* Selected True/False state */
input[type="radio"]:checked + .tf-option-label {
    background: rgba(37, 99, 235, 0.05);
    border-color: var(--color-primary);
}

.true-option input[type="radio"]:checked + .tf-option-label {
    background: rgba(16, 185, 129, 0.05);
    border-color: #10b981;
}

.false-option input[type="radio"]:checked + .tf-option-label {
    background: rgba(239, 68, 68, 0.05);
    border-color: #ef4444;
}

input[type="radio"]:checked + .tf-option-label .tf-icon {
    transform: scale(1.2);
}

/* Enhanced Feedback */
.feedback-card {
    border-radius: 12px;
    overflow: hidden;
    animation: fadeInUp 0.4s ease-out;
}

.feedback-header {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    padding: 1.5rem;
}

.feedback-icon {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: bold;
    flex-shrink: 0;
}

.feedback-content {
    flex: 1;
}

.feedback-result {
    font-size: 1.2rem;
    font-weight: 600;
    margin: 0;
}

.feedback-explanation {
    color: #6b7280;
    line-height: 1.5;
    margin-top: 0.5rem;
}

/* Correct feedback styling */
.alert-success .feedback-card {
    background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
    border: 2px solid #10b981;
}

.alert-success .feedback-icon {
    background: #10b981;
    color: white;
}

.alert-success .feedback-icon::before {
    content: '‚úì';
}

.alert-success .feedback-result {
    color: #065f46;
}

/* Incorrect feedback styling */
.alert-danger .feedback-card {
    background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
    border: 2px solid #ef4444;
}

.alert-danger .feedback-icon {
    background: #ef4444;
    color: white;
}

.alert-danger .feedback-icon::before {
    content: '‚úó';
}

.alert-danger .feedback-result {
    color: #991b1b;
}

/* Enhanced Navigation */
.quiz-navigation {
    border-top: 2px solid #f1f5f9;
    padding-top: 2rem;
}

.navigation-help {
    font-style: italic;
}

/* Animations */
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .quiz-progress-visual {
        text-align: center !important;
        margin-top: 1rem;
    }

    .quiz-progress-card .d-flex {
        flex-direction: column;
        align-items: stretch !important;
    }

    .quiz-progress-steps {
        overflow-x: auto;
        padding-bottom: 0.5rem;
    }

    .quiz-progress-steps .d-flex {
        min-width: max-content;
    }

    .question-word-highlight {
        padding: 0.75rem 1rem;
    }

    .featured-word {
        font-size: 1.25rem;
        display: block;
        margin: 0.5rem 0;
    }

    .definition-text {
        font-size: 1rem;
        padding-left: 1rem;
    }

    .option-content {
        padding: 1rem;
    }

    .option-details {
        flex-direction: column;
        gap: 0.5rem;
    }

    .detail-item {
        display: block;
        width: 100%;
        text-align: left;
    }

    .tf-option-content {
        padding: 1.5rem 1rem;
    }

    .quiz-navigation .d-flex {
        flex-direction: column;
        gap: 1rem;
    }

    .navigation-help {
        order: -1;
    }
}

/* Drag and Drop Styling for Matching Questions */
.matching-container .definition-item {
    transition: all 0.3s ease;
    cursor: move;
}

.matching-container .definition-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.matching-container .definition-item.drag-drop-target {
    background-color: #f8f9fa;
    border: 2px dashed #007bff;
}

.matching-container .drag-handle {
    cursor: grab;
    opacity: 0.6;
}

.matching-container .drag-handle:active {
    cursor: grabbing;
}

.matching-container .definition-item[draggable="true"]:hover .drag-handle {
    opacity: 1;
}

.matching-instructions {
    border-left: 4px solid #007bff;
}

.term-slot {
    background-color: #f8f9fa;
}

/* Responsive matching layout */
@media (max-width: 991px) {
    .matching-container .col-lg-7,
    .matching-container .col-lg-5 {
        margin-bottom: 2rem;
    }
}

/* Compact term slots for better space usage */
.term-slot .term-text {
    min-width: 120px;
    max-width: 150px;
}

.definition-drop-area {
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.3;
}

/* More compact definitions bank */
.definitions-bank {
    max-height: 60vh;
    overflow-y: auto;
    padding: 10px;
    border: 2px dashed transparent;
    border-radius: 8px;
    transition: all 0.3s ease;
}

/* Visual feedback when dragging over definitions bank */
.definitions-bank.drag-over {
    border-color: #28a745;
    background-color: #f8fff9;
}

.definitions-bank .definition-item {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.definitions-bank .definition-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.definition-number {
    min-width: 24px;
    text-align: center;
}

.term-number {
    min-width: 24px;
    text-align: center;
}

/* Enhanced drag and drop feedback */
.drop-zone.drag-active {
    border-color: #007bff !important;
    background-color: #e3f2fd !important;
}

.drop-zone.drag-over {
    border-color: #28a745 !important;
    background-color: #d4edda !important;
}

.definition-drop-area {
    transition: all 0.3s ease;
}

.term-slot.border-success {
    border-color: #28a745 !important;
}

.term-slot.border-warning {
    border-color: #ffc107 !important;
}

.definition-item .definition-content {
    /* Removed pointer-events: none as it was interfering with drag functionality */
    user-select: none; /* Prevent text selection during drag */
}

/* Modern Alpine.js Matching Quiz Styles */
.sortable-ghost {
    opacity: 0.5;
    background-color: #e3f2fd !important;
}

.sortable-chosen {
    transform: rotate(5deg);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.definition-item.selected {
    border-color: var(--color-primary) !important;
    box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    transform: scale(1.02);
}

.term-slot.can-drop {
    border-color: var(--color-primary) !important;
    background-color: rgba(37, 99, 235, 0.05);
}
</style>

<script>
// Alpine.js Component for Modern Matching Quiz
function matchingQuiz(questionId, terms, definitions, correctMatches) {
    return {
        questionId: questionId,
        terms: terms,
        definitions: definitions,
        correctMatches: correctMatches,
        assignments: {}, // termIndex -> definitionIndex
        selectedDefinition: null,
        sortables: {},

        init() {
            console.log('Initializing matching quiz for question:', questionId);
        },

        // Initialize Sortable.js for drag and drop (simplified)
        initSortable() {
            // Only initialize if this question is currently visible
            const questionCard = document.querySelector(`[data-question="${this.questionId}"]`);
            if (!questionCard || questionCard.style.display === 'none') {
                console.log(`Skipping Sortable init for question ${this.questionId} - not visible`);
                return;
            }
            console.log(`Initializing Sortable for visible question ${this.questionId}`);
            // Make definitions bank sortable (source only)
            const definitionsBank = document.getElementById('definitions-bank');
            console.log('Looking for definitions bank:', definitionsBank);
            if (definitionsBank) {
                console.log('Creating Sortable on definitions bank');
                this.sortables.definitionsBank = Sortable.create(definitionsBank, {
                    group: {
                        name: 'matching',
                        pull: 'clone', // Clone items for drag
                        put: false // Don't allow items back
                    },
                    sort: false,
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen'
                });
            }

            // Make each term slot a simple drop target
            this.terms.forEach((term, termIndex) => {
                const termSlot = document.getElementById(`term-slot-${termIndex}`);
                console.log(`Looking for term slot ${termIndex}:`, termSlot);
                if (termSlot) {
                    console.log(`Creating Sortable on term slot ${termIndex}`);
                    this.sortables[`term-${termIndex}`] = Sortable.create(termSlot, {
                        group: {
                            name: 'matching',
                            put: (to, from, dragEl, evt) => {
                                // Only allow drop if term slot is empty
                                const isEmpty = this.assignments[termIndex] === undefined;
                                console.log(`Put validation for term ${termIndex}: isEmpty=${isEmpty}`);
                                return isEmpty;
                            },
                            pull: true // Allow dragging out for rearrangement
                        },
                        revertOnSpill: true, // Return to original position if dropped in invalid location
                        removeOnSpill: false, // Don't remove elements on invalid drops
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        onAdd: (evt) => {
                            this.handleDropToTerm(evt, termIndex);
                        },
                        onRemove: (evt) => {
                            this.handleRemoveFromTerm(evt, termIndex);
                        }
                    });
                }
            });
        },

        // Handle drag and drop assignment
        handleDragEnd(evt) {
            // The actual assignment happens in onAdd of term slots
            console.log('Drag ended:', evt);
        },

        // Handle drop to term slot (simplified)
        handleDropToTerm(evt, termIndex) {
            const definitionIndex = parseInt(evt.item.dataset.defIndex);

            console.log('Dropped definition', definitionIndex, 'to term', termIndex);

            // Check if term already has assignment (safety check)
            if (this.assignments[termIndex] !== undefined) {
                console.warn('Term already has assignment, rejecting drop');
                // Don't remove the element - return it to original position instead
                return;
                return;
            }

            // Check if definition is already assigned elsewhere
            if (this.isAssigned(definitionIndex)) {
                console.warn('Definition already assigned elsewhere, rejecting drop');
                // Don't remove the element - return it to original position instead
                return;
                return;
            }

            // Hide the dropped Sortable element to prevent duplicates
            evt.item.style.display = 'none';

            // Assign the definition to the term
            this.assignDefinition(termIndex, definitionIndex);

            // Force immediate Alpine.js reactivity update
            console.log('Assignment updated:', termIndex, '->', definitionIndex);
            console.log('Current assignments state:', this.assignments);

            // Multiple approaches to force reactivity
            this.$nextTick(() => {
                console.log('$nextTick: checking assignment:', this.assignments[termIndex]);
                // Force update of all reactive elements
                this.$forceUpdate && this.$forceUpdate();

                // Also trigger a manual DOM update
                const termSlot = document.getElementById(`term-slot-${termIndex}`);
                if (termSlot) {
                    console.log('Manually triggering Alpine update on term slot');
                    // Force Alpine to re-evaluate the x-show directive
                    const assignedDiv = termSlot.querySelector('.assigned-definition');
                    const placeholderDiv = termSlot.querySelector('.drop-placeholder');
                    if (this.assignments[termIndex] !== undefined) {
                        if (assignedDiv) assignedDiv.style.display = 'block';
                        if (placeholderDiv) placeholderDiv.style.display = 'none';
                    }
                }
            });
        },

        // Handle removal from term slot (for rearrangement)
        handleRemoveFromTerm(evt, termIndex) {
            const definitionIndex = parseInt(evt.item.dataset.defIndex);
            console.log('Removed definition', definitionIndex, 'from term', termIndex);

            // Show the element again when removed
            evt.item.style.display = '';

            // Unassign the definition from the term
            this.removeAssignment(termIndex);

            // Force Alpine.js reactivity update
            this.$nextTick(() => {
                console.log('Unassignment updated:', termIndex, 'removed', definitionIndex);
                this.$forceUpdate && this.$forceUpdate();
            });
        },

        // Click-based definition selection
        selectDefinition(defIndex) {
            if (this.isAssigned(defIndex)) return;

            this.selectedDefinition = this.selectedDefinition === defIndex ? null : defIndex;
        },

        // Assign selected definition to term (click method)
        assignSelectedToTerm(termIndex) {
            if (this.selectedDefinition === null) return;
            if (this.assignments[termIndex] !== undefined) return; // Already has assignment

            this.assignDefinition(termIndex, this.selectedDefinition);
            this.selectedDefinition = null;
        },

        // Core assignment logic
        assignDefinition(termIndex, defIndex) {
            // Remove any existing assignment for this definition
            Object.keys(this.assignments).forEach(key => {
                if (this.assignments[key] === defIndex) {
                    delete this.assignments[key];
                }
            });

            // Remove any existing assignment for this term
            if (this.assignments[termIndex] !== undefined) {
                delete this.assignments[termIndex];
            }

            // Make the assignment
            this.assignments[termIndex] = defIndex;

            console.log('Assignment made:', termIndex, '->', defIndex);
            console.log('Current assignments:', this.assignments);
        },

        // Remove assignment
        removeAssignment(termIndex) {
            delete this.assignments[termIndex];
            console.log('Assignment removed for term:', termIndex);
        },

        // Helper functions
        isAssigned(defIndex) {
            return Object.values(this.assignments).includes(defIndex);
        },

        getDefinitionText(defIndex) {
            return this.definitions[defIndex] || '';
        },

        getAvailableCount() {
            return this.definitions.length - Object.keys(this.assignments).length;
        },

        getTermSlotClass(termIndex) {
            const classes = ['border'];

            if (this.assignments[termIndex] !== undefined) {
                classes.push('border-success');
            } else if (this.selectedDefinition !== null) {
                classes.push('can-drop', 'border-primary');
            } else {
                classes.push('border-muted');
            }

            return classes.join(' ');
        },

        getDefinitionClass(defIndex) {
            const classes = ['border'];

            // TEMPORARILY DISABLE ASSIGNMENT LOGIC TO TEST
            if (false && this.isAssigned(defIndex)) {
                // Keep assigned definitions visible but clearly marked as used
                classes.push('border-secondary', 'bg-secondary', 'bg-opacity-25');
            } else if (this.selectedDefinition === defIndex) {
                classes.push('selected', 'border-primary');
            } else {
                classes.push('border-success');
            }

            return classes.join(' ');
        },

        // Validation and scoring (for integration with existing quiz system)
        getAnswerData() {
            return {
                questionId: this.questionId,
                questionType: 'matching',
                assignments: this.assignments,
                isComplete: Object.keys(this.assignments).length === this.terms.length
            };
        },

        // Check if all terms are matched
        isComplete() {
            return Object.keys(this.assignments).length === this.terms.length;
        }
    };
}

// Version that reads data from DOM instead of parameters
function matchingQuizFromDOM(questionId) {
    try {
        const dataScript = document.getElementById(`question-${questionId}-data`);
        if (!dataScript) {
            console.error(`No data script found for question ${questionId}`);
            return matchingQuiz(questionId, ["Error"], ["No data found"], {0: 0});
        }

        const data = JSON.parse(dataScript.textContent);
        return matchingQuiz(questionId, data.terms, data.definitions, data.correct_matches);
    } catch (error) {
        console.error('Error parsing question data:', error);
        return matchingQuiz(questionId, ["Error"], ["Failed to load data"], {0: 0});
    }
}

// Make functions globally available for Alpine.js
window.matchingQuiz = matchingQuiz;
window.matchingQuizFromDOM = matchingQuizFromDOM;

// Initialize the quiz by showing the first question
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded - initializing quiz with first question');
    showQuestion(questionIds[0]); // Show the first question by ID
    updateProgress();
});
</script>

{% endblock %}